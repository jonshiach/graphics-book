

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>7. Moving the camera &#8212; Computer Graphics</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"vec": ["\\mathbf{#1}", 1], "model": ["M\\!odel"], "view": ["V\\!iew"], "mvp": ["MV\\!P"]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_pages/07_Moving_the_camera';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="8. Lighting" href="08_Lighting.html" />
    <link rel="prev" title="6. 3D Worlds" href="06_3D_worlds.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.svg" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.svg" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Computer Graphics
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="01_intro_to_cpp.html">1. Introduction to C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_basic_shapes_in_OpenGL.html">2. Basic Shapes in OpenGL</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_textures.html">3. Textures</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_vectors_and_matrices.html">4. Vectors and Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_transformations.html">5. Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_3D_worlds.html">6. 3D Worlds</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">7. Moving the camera</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_Lighting.html">8. Lighting</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_Normal_mapping.html">9. Normal Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_Quaternions.html">10. Quaternions</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="A_Complex_numbers_and_quaternions.html">A. Complex Numbers and Quaternions</a></li>
<li class="toctree-l1"><a class="reference internal" href="B_Code.html">B. Code and Assets</a></li>
<li class="toctree-l1"><a class="reference internal" href="C_Glossary.html">C Glossary</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs/issues/new?title=Issue%20on%20page%20%2F_pages/07_Moving_the_camera.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/_pages/07_Moving_the_camera.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Moving the camera</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-keyboard-input-to-move-the-camera">7.1. Using keyboard input to move the camera</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#getting-the-keyboard-input">7.1.1. Getting the keyboard input</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#controlling-the-speed-of-the-camera">7.2. Controlling the speed of the camera.</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-the-mouse-to-point-the-camera">7.3. Using the mouse to point the camera</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#yaw-pitch-and-roll">7.3.1. Yaw, pitch and roll</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pointing-the-camera">7.3.2. Pointing the camera</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#changing-the-field-of-view-angle-using-scroll-wheel">7.4. Changing the field of view angle using scroll wheel</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#back-face-culling">7.5. Back face culling</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">7.6. Exercises</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="moving-the-camera">
<span id="moving-the-camera-section"></span><h1><span class="section-number">7. </span>Moving the camera<a class="headerlink" href="#moving-the-camera" title="Permalink to this heading">#</a></h1>
<p>In the <a class="reference internal" href="06_3D_worlds.html#d-worlds-section"><span class="std std-ref">previous lab</span></a> we saw how we use transformations to build a 3D world, align the world to the camera position and project the view space onto the screen space. We also created a Camera class to contains functions to perform these calculations. The next step is to modify the Camera class to by able to move and direct the camera around the 3D world.</p>
<p>Compile and run the <strong>Lab07_Moving_the_camera</strong> project and you will see the multiple cube example we created at the end of the last lab.</p>
<figure class="align-default" id="moving-the-camera-figure">
<a class="reference internal image-reference" href="../_images/07_Moving_the_camera.png"><img alt="../_images/07_Moving_the_camera.png" src="../_images/07_Moving_the_camera.png" style="width: 500px;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 7.1 </span><span class="caption-text">Multiple cubes from <a class="reference internal" href="06_3D_worlds.html#d-worlds-section"><span class="std std-ref">6. 3D Worlds</span></a>.</span><a class="headerlink" href="#moving-the-camera-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<section id="using-keyboard-input-to-move-the-camera">
<h2><span class="section-number">7.1. </span>Using keyboard input to move the camera<a class="headerlink" href="#using-keyboard-input-to-move-the-camera" title="Permalink to this heading">#</a></h2>
<p>The first thing we need to do is add a method to our <code class="docutils literal notranslate"><span class="pre">Camera</span></code> class to move the camera in the world space. We want to be able to move the camera forward and backwards, left and right, up and down. Recall the <a class="reference internal" href="06_3D_worlds.html#view-matrix-section"><span class="std std-ref">view matrix</span></a> from the <a class="reference internal" href="06_3D_worlds.html#d-worlds-section"><span class="std std-ref">previous lab</span></a></p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    View &amp;=
    \begin{pmatrix}
        r_x &amp; r_y &amp; r_z &amp; -\vec{eye} \cdot \vec{right} \\
        u_x &amp; u_y &amp; u_z &amp; -\vec{eye} \cdot \vec{up} \\
        -f_x &amp; -f_y &amp;- f_z &amp; \vec{eye} \cdot \vec{front} \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix},
\end{align*} \end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\vec{right} = (r_x, r_y, r_z)\)</span>, <span class="math notranslate nohighlight">\(\vec{up} = (u_x, u_y, u_z)\)</span> and <span class="math notranslate nohighlight">\(\vec{front} = (f_x, f_y, f_z)\)</span>. Since these three vectors point to the right, up and to the front of the camera we can use these to move the camera in those directions. For example, to move the camera forwards and backwards we simply add and subtract the <span class="math notranslate nohighlight">\(\vec{front}\)</span> vector to the camera position which is the <span class="math notranslate nohighlight">\(\vec{eye}\)</span> vector (<a class="reference internal" href="#camera-movement-figure"><span class="std std-numref">Fig. 7.2</span></a>).</p>
<figure class="align-default" id="camera-movement-figure">
<a class="reference internal image-reference" href="../_images/07_camera_movement.svg"><img alt="../_images/07_camera_movement.svg" src="../_images/07_camera_movement.svg" width="500" /></a>
<figcaption>
<p><span class="caption-number">Fig. 7.2 </span><span class="caption-text">Moving the camera forwards and backwards.</span><a class="headerlink" href="#camera-movement-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>First we need to extract the <span class="math notranslate nohighlight">\(\vec{right}\)</span>, <span class="math notranslate nohighlight">\(\vec{up}\)</span> and <span class="math notranslate nohighlight">\(\vec{front}\)</span> vectors from the view matrix. Add the following camera vectors to the class definition in the <strong>camera.hpp</strong> file so they can be accessed outside of the <code class="docutils literal notranslate"><span class="pre">lookAt()</span></code> function</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">vec3</span><span class="w"> </span><span class="n">right</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">up</span><span class="w">      </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="n">vec3</span><span class="w"> </span><span class="n">front</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">);</span>
</pre></div>
</div>
<p>and in the <strong>camera.cpp</strong> file add the following code to the <code class="docutils literal notranslate"><span class="pre">calculateMatrices()</span></code> function after the view matrix is calculated.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Update camera vectors</span>
<span class="n">right</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w">   </span><span class="n">view</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="n">right</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w">   </span><span class="n">view</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="w"> </span><span class="n">right</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w">   </span><span class="n">view</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="n">up</span><span class="p">.</span><span class="n">x</span><span class="w">    </span><span class="o">=</span><span class="w">   </span><span class="n">view</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="n">up</span><span class="p">.</span><span class="n">y</span><span class="w">    </span><span class="o">=</span><span class="w">   </span><span class="n">view</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span><span class="w"> </span><span class="n">up</span><span class="p">.</span><span class="n">z</span><span class="w">    </span><span class="o">=</span><span class="w">   </span><span class="n">view</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
<span class="n">front</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">view</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="n">front</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">view</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span><span class="w"> </span><span class="n">front</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">view</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</pre></div>
</div>
<p>Note that the third row of the view matrix is <span class="math notranslate nohighlight">\(-\vec{front}\)</span> so we need to change the sign of the these elements. We now need a class method to move the camera, add the following method declaration to the <code class="docutils literal notranslate"><span class="pre">Camera</span></code> class.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">move</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">direction</span><span class="p">);</span>
</pre></div>
</div>
<p>Then define this method in the <strong>camera.cpp</strong> folder by entering the following code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">Camera::move</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">direction</span><span class="p">)</span>
<span class="p">{</span><span class="w"> </span>
<span class="w">    </span><span class="c1">// Move camera</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;forward&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="n">eye</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">front</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;backward&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="n">eye</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">front</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;left&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="n">eye</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;right&quot;</span><span class="p">)</span>
<span class="w">        </span><span class="n">eye</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we add/subtract the <span class="math notranslate nohighlight">\(\vec{front}\)</span> or <span class="math notranslate nohighlight">\(\vec{right}\)</span> vectors to/from the <span class="math notranslate nohighlight">\(\vec{eye}\)</span> vector depending on the value of the string <code class="docutils literal notranslate"><span class="pre">direction</span></code>.</p>
<section id="getting-the-keyboard-input">
<h3><span class="section-number">7.1.1. </span>Getting the keyboard input<a class="headerlink" href="#getting-the-keyboard-input" title="Permalink to this heading">#</a></h3>
<p>We need to get keyboard input from the user and use it to invoke our <code class="docutils literal notranslate"><span class="pre">move()</span></code> method. If you take a look at the <strong>Lab07_Moving_the_camera.cpp</strong> file at the bottom we have the function <code class="docutils literal notranslate"><span class="pre">keyboardInput()</span></code> which currently contains a single if statement that uses the function <code class="docutils literal notranslate"><span class="pre">glfwGetKey()</span></code> to detect whether the escape key has been pressed. This is called in the render loop so that at each frame the program is checking for keyboard inputs. Add the following code to the <code class="docutils literal notranslate"><span class="pre">keyboardInput()</span></code> function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Move camera</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">GLFW_KEY_W</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">GLFW_PRESS</span><span class="p">)</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="s">&quot;forward&quot;</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">GLFW_KEY_S</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">GLFW_PRESS</span><span class="p">)</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="s">&quot;backward&quot;</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">GLFW_KEY_A</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">GLFW_PRESS</span><span class="p">)</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="s">&quot;left&quot;</span><span class="p">);</span>

<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">glfwGetKey</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">GLFW_KEY_D</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">GLFW_PRESS</span><span class="p">)</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="n">move</span><span class="p">(</span><span class="s">&quot;right&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Here we’ve used the classic WSAD key combination to control the movement of the camera. Run your program and experiment with moving the camera.</p>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/07_keyboard_1.mp4" type="video/mp4">
</video>
</center>
<p>You will notice that when the camera is moved left to right using the A and D keys the camera rotates around the first cube. This because our camera is always pointing towards <span class="math notranslate nohighlight">\((0,0,0)\)</span> as the <code class="docutils literal notranslate"><span class="pre">lookat()</span></code> function uses the <span class="math notranslate nohighlight">\(\vec{target}\)</span> vector to calculate the view matrix. To fix this we simply change <code class="docutils literal notranslate"><span class="pre">target</span></code> to <code class="docutils literal notranslate"><span class="pre">eye</span> <span class="pre">+</span> <span class="pre">front</span></code> in the function call to <code class="docutils literal notranslate"><span class="pre">lookAt()</span></code> so that the camera is always pointing forwards (for now).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate the view matrix</span>
<span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">eye</span><span class="p">,</span><span class="w"> </span><span class="n">eye</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">front</span><span class="p">,</span><span class="w"> </span><span class="n">worldUp</span><span class="p">);</span>
</pre></div>
</div>
<p>Run your program and you should see that the camera always points down the <span class="math notranslate nohighlight">\(z\)</span>-axis.</p>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/07_keyboard_2.mp4" type="video/mp4">
</video>
</center>
</section>
</section>
<section id="controlling-the-speed-of-the-camera">
<h2><span class="section-number">7.2. </span>Controlling the speed of the camera.<a class="headerlink" href="#controlling-the-speed-of-the-camera" title="Permalink to this heading">#</a></h2>
<p>Playing around with the camera movement you will also notice that the controls are quite sensitive and not very satisfying to use. To fix this we can control the speed at which the camera moves in the world space.  Add an attribute for the camera speed to the <code class="docutils literal notranslate"><span class="pre">Camera</span></code> class by adding the following code to the <code class="docutils literal notranslate"><span class="pre">Camera</span></code> class method.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Camera parameters</span>
<span class="kt">float</span><span class="w"> </span><span class="n">cameraSpeed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.0f</span><span class="p">;</span>
</pre></div>
</div>
<p>Speed is distance divided by time so to ensure that the camera moves at our chosen speed of 5 units per second we need to input the <code class="docutils literal notranslate"><span class="pre">deltaTime</span></code> variable (the time that has elapsed between the two successive iterations of the render loop) into the <code class="docutils literal notranslate"><span class="pre">move()</span></code> method. Edit the method declaration so that it takes in a second input of <code class="docutils literal notranslate"><span class="pre">deltaTime</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">move</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">direction</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">deltaTime</span><span class="p">);</span>
</pre></div>
</div>
<p>and edit the <code class="docutils literal notranslate"><span class="pre">move()</span></code> method definition so it uses <code class="docutils literal notranslate"><span class="pre">mouseSpeed</span></code> and <code class="docutils literal notranslate"><span class="pre">deltaTime</span></code> to move the <span class="math notranslate nohighlight">\(\vec{eye}\)</span> vector in the chosen direction and at the chosen speed, e.g.,</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">direction</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&quot;forward&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="n">eye</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">cameraSpeed</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">deltaTime</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">front</span><span class="p">;</span>
</pre></div>
</div>
<p>and do similar for the other three directions. Since <span class="math notranslate nohighlight">\(\vec{front}\)</span> and <span class="math notranslate nohighlight">\(\vec{right}\)</span> are unit vectors our camera now moves at 5 units per second (of course we can change this to suit out needs, e.g., simulating a character sprinting in a first person shooter game).</p>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/07_keyboard_3.mp4" type="video/mp4">
</video>
</center>
</section>
<section id="using-the-mouse-to-point-the-camera">
<h2><span class="section-number">7.3. </span>Using the mouse to point the camera<a class="headerlink" href="#using-the-mouse-to-point-the-camera" title="Permalink to this heading">#</a></h2>
<p>We can now move the camera position using keyboard inputs but we can’t yet point the camera in a difference direction. This is usually done using mouse inputs but can also done using keyboard or game controllers.</p>
<p>First we need to capture the mouse inputs. Take a look at the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function, just after the window is created we call the <code class="docutils literal notranslate"><span class="pre">glfwSetInputMode()</span></code> which enables use to capture the keyboard inputs. So to capture the mouse input we need to do similar. Enter the following code just after we capture the keyboard inputs.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Capture mouse inputs</span>
<span class="n">glfwSetInputMode</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">GLFW_CURSOR</span><span class="p">,</span><span class="w"> </span><span class="n">GLFW_CURSOR_DISABLED</span><span class="p">);</span>
<span class="n">glfwPollEvents</span><span class="p">();</span>
<span class="n">glfwSetCursorPos</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">768</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="n">glfwSetCursorPosCallback</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">mouseCallback</span><span class="p">);</span>
</pre></div>
</div>
<p>These functions are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">glfwSetInputMode()</span></code> - captures the mouse input (in addition to the earlier call to the same function to capture the keyboard inputs) and hides the mouse cursor</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">glfwPollEvents()</span></code> - processes any events in the event queue, in other words it checks for a mouse input right away</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">glfwSetCursorPos()</span></code> - specifies the position of the mouse cursor in the window, here we have set this to the centre of the window</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">glfwSetCursorPosCallback()</span></code> - specifies that we call the callback function <code class="docutils literal notranslate"><span class="pre">mouseCallBack()</span></code> (not yet written) which is executed when GLFW detects a change in the cursor position.</p></li>
</ul>
<section id="yaw-pitch-and-roll">
<h3><span class="section-number">7.3.1. </span>Yaw, pitch and roll<a class="headerlink" href="#yaw-pitch-and-roll" title="Permalink to this heading">#</a></h3>
<p>The direction which the camera is pointing is governed by three angles called <span class="math notranslate nohighlight">\(yaw\)</span>, <span class="math notranslate nohighlight">\(pitch\)</span> and <span class="math notranslate nohighlight">\(roll\)</span> which are collectively known as <a href="https://en.wikipedia.org/wiki/Euler_angles" target="_blank"><strong>Euler angles</strong></a>. The name of these come from the aviation industry where they are related to the direction that an aircraft is facing. A plane on the ground first needs to taxi to the end of a runway which is does by steering left and right in the horizontal direction by changing its <span class="math notranslate nohighlight">\(yaw\)</span> angle. Then on take off it can point its nose upwards in the vertical direction by changing its <span class="math notranslate nohighlight">\(pitch\)</span> angle. Once airborne the plane can move its wingtips up and down thus changing its <span class="math notranslate nohighlight">\(roll\)</span> angle. Our camera is analogous to the plane (<a class="reference internal" href="#yaw-pitch-roll-figure"><span class="std std-numref">Fig. 7.3</span></a>).</p>
<figure class="align-default" id="yaw-pitch-roll-figure">
<a class="reference internal image-reference" href="../_images/07_yaw_pitch_roll.svg"><img alt="../_images/07_yaw_pitch_roll.svg" src="../_images/07_yaw_pitch_roll.svg" width="250" /></a>
<figcaption>
<p><span class="caption-number">Fig. 7.3 </span><span class="caption-text">Yaw, pitch and roll</span><a class="headerlink" href="#yaw-pitch-roll-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>To point our camera we only need the <span class="math notranslate nohighlight">\(yaw\)</span> and <span class="math notranslate nohighlight">\(pitch\)</span> angles which we are going to change using mouse inputs such that when the mouse is moved left and right the <span class="math notranslate nohighlight">\(yaw\)</span> angle changes and when the mouse is moved up and down the <span class="math notranslate nohighlight">\(pitch\)</span> angle changes. The problem we have is that our <code class="docutils literal notranslate"><span class="pre">lookAt()</span></code> function uses the <span class="math notranslate nohighlight">\(\vec{front}\)</span> vector to calculate the <span class="math notranslate nohighlight">\(view\)</span> matrix so we need some way of calculating the <span class="math notranslate nohighlight">\(\vec{front}\)</span> vector from the <span class="math notranslate nohighlight">\(yaw\)</span> and <span class="math notranslate nohighlight">\(pitch\)</span> angles.</p>
<p>To do this we look at what happens to the vector <span class="math notranslate nohighlight">\((0,0,1)\)</span>, that points along the <span class="math notranslate nohighlight">\(z\)</span>-axis, when the mouse cursor is moved. If the mouse cursor is moved to the left then the vector <span class="math notranslate nohighlight">\((0,0,1)\)</span> is rotated anti-clockwise about the <span class="math notranslate nohighlight">\(y\)</span>-axis.</p>
<figure class="align-default" id="yaw-figure">
<a class="reference internal image-reference" href="../_images/07_yaw.svg"><img alt="../_images/07_yaw.svg" src="../_images/07_yaw.svg" width="300" /></a>
<figcaption>
<p><span class="caption-number">Fig. 7.4 </span><span class="caption-text">Yaw movement is rotation about the <span class="math notranslate nohighlight">\(y\)</span>-axis.</span><a class="headerlink" href="#yaw-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The <a class="reference internal" href="05_transformations.html#rotation-section"><span class="std std-ref">rotation matrix</span></a> for rotating anti-clockwise about the <span class="math notranslate nohighlight">\(y\)</span>-axis is</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    R_y =
    \begin{pmatrix}
        \cos(yaw) &amp; 0 &amp; \sin(yaw) \\
        0 &amp; 1 &amp; 0 \\
        -\sin(yaw) &amp; 0 &amp; \cos(yaw)
    \end{pmatrix}.
\end{align*} \end{split}\]</div>
<p>Similarly, if the cursor is moved downwards then this represents a rotation of the <span class="math notranslate nohighlight">\((0,0,1)\)</span> vector clockwise about the <span class="math notranslate nohighlight">\(x\)</span>-axis.</p>
<figure class="align-default" id="pitch-figure">
<a class="reference internal image-reference" href="../_images/07_pitch.svg"><img alt="../_images/07_pitch.svg" src="../_images/07_pitch.svg" width="300" /></a>
<figcaption>
<p><span class="caption-number">Fig. 7.5 </span><span class="caption-text">Pitch movement is rotation about the <span class="math notranslate nohighlight">\(x\)</span>-axis.</span><a class="headerlink" href="#pitch-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The rotation matrix for rotating clockwise about the <span class="math notranslate nohighlight">\(x\)</span>-axis is (note that the negative sign is now next to the lower left <span class="math notranslate nohighlight">\(\sin\)</span> function as opposed to the upper-right for rotating <a class="reference internal" href="05_transformations.html#rotation-section"><span class="std std-ref">anti-clockwise</span></a> about the <span class="math notranslate nohighlight">\(x\)</span>-axis)</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
  R_x &amp;= 
  \begin{pmatrix}
    1 &amp; 0 &amp; 0 \\
    0 &amp;   \cos(pitch) &amp; \sin(pitch) \\
    0 &amp;  -\sin(pitch) &amp;  \cos(pitch)
  \end{pmatrix}.
\end{align*} \end{split}\]</div>
<p>Applying the <span class="math notranslate nohighlight">\(yaw\)</span> and <span class="math notranslate nohighlight">\(pitch\)</span> rotations to the <span class="math notranslate nohighlight">\((0,0,1)\)</span> vector means calculating <span class="math notranslate nohighlight">\(\vec{front} = R_y\cdot R_x \cdot (0, 0, 1)^\mathsf{T}\)</span></p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    R_y \cdot R_x \cdot \begin{pmatrix} 0 \\ 0 \\ 1 \end{pmatrix} &amp;=
    \begin{pmatrix}
         \cos(yaw) &amp; 0 &amp; \sin(yaw) \\
         0 &amp; 1 &amp; 0 \\
        -\sin(yaw) &amp; 0 &amp; \cos(yaw)
    \end{pmatrix}
    \begin{pmatrix}
        1 &amp; 0 &amp; 0 \\
        0 &amp;  \cos(pitch) &amp; -\sin(pitch) \\
        0 &amp; -\sin(pitch) &amp;  \cos(pitch)
    \end{pmatrix}
    \begin{pmatrix} 0 \\ 0 \\ 1 \end{pmatrix} \\
    &amp;=
    \begin{pmatrix}
          \cos(yaw) &amp; -\sin(yaw) \sin(pitch) &amp; \sin(yaw) \cos(pitch) \\
         0          &amp; \cos(pitch)            &amp; \sin(pitch) \\
         -\sin(yaw) &amp; -\cos(yaw) \sin(pitch) &amp; \cos(yaw) \cos(pitch)
    \end{pmatrix}
    \begin{pmatrix} 0 \\ 0 \\ 1 \end{pmatrix} \\
    &amp;=
    \begin{pmatrix}
        \sin(yaw) \cos(pitch) \\
        \sin(pitch) \\
        \cos(yaw) \cos(pitch)
    \end{pmatrix}.
\end{align*} \end{split}\]</div>
<p>So the <span class="math notranslate nohighlight">\(\vec{front}\)</span> vector is</p>
<div class="math notranslate nohighlight">
\[ \vec{front} = \operatorname{normalise} (\sin(yaw)\cos(pitch), \sin(pitch), \cos(yaw)\cos(pitch)). \]</div>
<p>To apply this to our <code class="docutils literal notranslate"><span class="pre">Camera</span></code> class we need to add attributes for the <span class="math notranslate nohighlight">\(yaw\)</span>, <span class="math notranslate nohighlight">\(pitch\)</span> and <span class="math notranslate nohighlight">\(roll\)</span> Euler angles. Add the following code to the camera parameters in the <code class="docutils literal notranslate"><span class="pre">Camera</span></code> class declaration.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">yaw</span><span class="w">         </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">180.0f</span><span class="p">);</span>
<span class="kt">float</span><span class="w"> </span><span class="n">pitch</span><span class="w">       </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">roll</span><span class="w">        </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
</pre></div>
</div>
<p>Here we have set the <span class="math notranslate nohighlight">\(pitch\)</span> and <span class="math notranslate nohighlight">\(roll\)</span> angles to <span class="math notranslate nohighlight">\(0^\circ\)</span> and <span class="math notranslate nohighlight">\(yaw\)</span> to <span class="math notranslate nohighlight">\(180^\circ\)</span> since the <span class="math notranslate nohighlight">\(\vec{front}\)</span> vector is initially pointing down the negative <span class="math notranslate nohighlight">\(z\)</span>-axis. Then in the <strong>Camera.cpp</strong> file edit the <code class="docutils literal notranslate"><span class="pre">calculateMatrices()</span></code> method so that the <span class="math notranslate nohighlight">\(\vec{front}\)</span> vector is calculated from the Euler angles prior to calculating the view matrix</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate view matrix</span>
<span class="n">front</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">yaw</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">pitch</span><span class="p">);</span>
<span class="n">front</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">pitch</span><span class="p">);</span>
<span class="n">front</span><span class="p">.</span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">yaw</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">pitch</span><span class="p">);</span>
<span class="n">front</span><span class="p">.</span><span class="n">normalise</span><span class="p">();</span>

<span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">eye</span><span class="p">,</span><span class="w"> </span><span class="n">eye</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">front</span><span class="p">,</span><span class="w"> </span><span class="n">worldUp</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="pointing-the-camera">
<h3><span class="section-number">7.3.2. </span>Pointing the camera<a class="headerlink" href="#pointing-the-camera" title="Permalink to this heading">#</a></h3>
<p>The <span class="math notranslate nohighlight">\(yaw\)</span> and <span class="math notranslate nohighlight">\(pitch\)</span> Euler angles are to be changed using a callback function that handles the mouse movement. In the <strong>Lab07_Moving_the_camera.cpp</strong> file add the following function prototype near the top of the file where we have one for the <code class="docutils literal notranslate"><span class="pre">keyboardInputs()</span></code> function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mouseCallback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="w"> </span><span class="o">*</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">xPos</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">yPos</span><span class="p">);</span>
</pre></div>
</div>
<p>Then at the bottom of the file define the function by entering the following code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">mouseCallback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="w"> </span><span class="o">*</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">xPos</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">yPos</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Update yaw and pitch angles</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">xOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="p">(</span><span class="mi">1024</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">xPos</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">yOffset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kt">float</span><span class="p">(</span><span class="w"> </span><span class="mi">768</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">yPos</span><span class="p">);</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="n">yaw</span><span class="w">   </span><span class="o">+=</span><span class="w"> </span><span class="n">xOffset</span><span class="p">;</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="n">pitch</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">yOffset</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Reset mouse cursor position to centre</span>
<span class="w">    </span><span class="n">glfwSetCursorPos</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">768</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This function takes inputs of a pointer to the <code class="docutils literal notranslate"><span class="pre">window</span></code> object and two variables <code class="docutils literal notranslate"><span class="pre">xPos</span></code> and <code class="docutils literal notranslate"><span class="pre">yPos</span></code> which are the number of pixels across and down from the left-hand and top edges of the window respectively. The variables <code class="docutils literal notranslate"><span class="pre">xOffset</span></code> and <code class="docutils literal notranslate"><span class="pre">yOffset</span></code> are calculated as the distance of the cursor from the centre of the window in the horizontal and vertical directions respectively. A positive offset value meaning the cursor is to the left and below the centre (<a class="reference internal" href="#cursor-figure"><span class="std std-numref">Fig. 7.6</span></a>).</p>
<figure class="align-default" id="cursor-figure">
<a class="reference internal image-reference" href="../_images/07_cursor.svg"><img alt="../_images/07_cursor.svg" src="../_images/07_cursor.svg" width="300" /></a>
<figcaption>
<p><span class="caption-number">Fig. 7.6 </span><span class="caption-text"><span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> offset values are the distance in pixels from the window centre.</span><a class="headerlink" href="#cursor-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The <span class="math notranslate nohighlight">\(yaw\)</span> and <span class="math notranslate nohighlight">\(pitch\)</span> attributes of the <code class="docutils literal notranslate"><span class="pre">camera</span></code> object are incremented by the offset values. For example, if the cursor is moved to the left then <code class="docutils literal notranslate"><span class="pre">xOffset</span></code> is a positive value so that <span class="math notranslate nohighlight">\(yaw\)</span> angle increases and the camera rotates anti-clockwise about the <span class="math notranslate nohighlight">\(y\)</span>-axis (<a class="reference internal" href="#yaw-figure"><span class="std std-numref">Fig. 7.4</span></a>). Similarly, if the cursor is moved downwards then <code class="docutils literal notranslate"><span class="pre">yOffset</span></code> is positive and the <span class="math notranslate nohighlight">\(pitch\)</span> angle increases and the camera rotates clockwise about the <span class="math notranslate nohighlight">\(x\)</span>-axis (<a class="reference internal" href="#pitch-figure"><span class="std std-numref">Fig. 7.5</span></a>). After incrementing the <span class="math notranslate nohighlight">\(yaw\)</span> and <span class="math notranslate nohighlight">\(pitch\)</span> angles we reset the mouse cursor to the centre of the window. If we didn’t do this the cursor would soon go outside of our window and we wouldn’t be able to point the camera in a different direction.</p>
<p>If you compile and run your program you may notice that the mouse controls are far too sensitive and we need to slow down the speed of rotation. To do this add an attribute to the camera parameters called <code class="docutils literal notranslate"><span class="pre">mouseSpeed</span></code> and initialise it to some small number (you may need to experiment with this value to dial in the sensitivity you want).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">float</span><span class="w"> </span><span class="n">mouseSpeed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.001f</span><span class="p">;</span>
</pre></div>
</div>
<p>Then change the <code class="docutils literal notranslate"><span class="pre">yaw</span></code> and <code class="docutils literal notranslate"><span class="pre">pitch</span></code> calculations in the <code class="docutils literal notranslate"><span class="pre">mouseCallback()</span></code> function to the following</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">camera</span><span class="p">.</span><span class="n">yaw</span><span class="w">   </span><span class="o">+=</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">mouseSpeed</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">xOffset</span><span class="p">;</span>
<span class="n">camera</span><span class="p">.</span><span class="n">pitch</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">mouseSpeed</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">yOffset</span><span class="p">;</span>
</pre></div>
</div>
<p>Running the program and we can now move around our world space and point the camera in any direction we want (well, almost any direction).</p>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/07_mouse.mp4" type="video/mp4">
</video>
</center>
</section>
</section>
<hr class="docutils" />
<section id="changing-the-field-of-view-angle-using-scroll-wheel">
<h2><span class="section-number">7.4. </span>Changing the field of view angle using scroll wheel<a class="headerlink" href="#changing-the-field-of-view-angle-using-scroll-wheel" title="Permalink to this heading">#</a></h2>
<p>Recall in the <a class="reference internal" href="06_3D_worlds.html#changing-the-fov-section"><span class="std std-ref">previous lab</span></a> that changing the field of view angle used in the calculation of the perspective projection matrix had the effect of zooming in and out of the scene. We can use the scroll wheel to control the field of view angle. To do this we need another callback function for the scroll wheel, after we use the <code class="docutils literal notranslate"><span class="pre">glfwSetCursorCallback()</span></code> add the following code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glfwSetScrollCallback</span><span class="p">(</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="n">scrollCallback</span><span class="p">);</span>
</pre></div>
</div>
<p>This tells GLFW that we want something to happen when the scroll wheel is used. We need to declare and define the <code class="docutils literal notranslate"><span class="pre">scrollCallback()</span></code> function so add a function prototype before the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">scrollCallback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="w"> </span><span class="o">*</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">xOffset</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">yOffset</span><span class="p">);</span>
</pre></div>
</div>
<p>and then at the bottom of the file define the function</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">scrollCallback</span><span class="p">(</span><span class="n">GLFWwindow</span><span class="w"> </span><span class="o">*</span><span class="n">window</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">xOffset</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">yOffset</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Change field of view angle</span>
<span class="w">    </span><span class="n">camera</span><span class="p">.</span><span class="n">fov</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mf">0.05f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="n">yOffset</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Restrict the fov angle</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">fov</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">5.0f</span><span class="p">))</span>
<span class="w">        </span><span class="n">camera</span><span class="p">.</span><span class="n">fov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">5.0f</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">camera</span><span class="p">.</span><span class="n">fov</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">120.0f</span><span class="p">))</span>
<span class="w">        </span><span class="n">camera</span><span class="p">.</span><span class="n">fov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Maths</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">120.0f</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Most scroll wheels only return a horizontal scroll value which we have called <code class="docutils literal notranslate"><span class="pre">yOffset</span></code> and the <span class="math notranslate nohighlight">\(fov\)</span> angle is incremented or decremented based on this value (which is also multiplied by 0.05 to limit the changes, you may need to experiment with this value to get it right). We also need to limit the range of values that the <span class="math notranslate nohighlight">\(fov\)</span> angle can take which we have done using the if statements.</p>
<p>Run your program and play around with the scroll wheel and you should see something like the following.</p>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/07_scroll_wheel.mp4" type="video/mp4">
</video>
</center>
<p>It may seem like the position of the camera is changing but what is actually happening is that changes to the field of view angle is changing the size of the viewing frustum thus causing the cubes to change size. It is a common trope in first-person shooter games to render the outline of a scope or binoculars to remind the player that they are zooming in and not moving forward.</p>
</section>
<hr class="docutils" />
<section id="back-face-culling">
<h2><span class="section-number">7.5. </span>Back face culling<a class="headerlink" href="#back-face-culling" title="Permalink to this heading">#</a></h2>
<p>Whilst moving your camera around your 3D world you may notice that we can move through objects and view them from the inside. All surfaces of the cubes are rendered, including those not visible from the camera because they are on the far side of the cubes. This is a waste of resources as OpenGL is calculating the vertex and fragment shaders for objects that won’t be shown in the frame. To overcome this we can cull (omit) any surface of an object that is <strong>back facing</strong> the camera in a method called <strong>back face culling</strong>.</p>
<p id="normal-vector-section">A <strong>normal vector</strong> (often just referred to as a <strong>normal</strong>) is a vector denoted by <span class="math notranslate nohighlight">\(\vec{n}\)</span> that is perpendicular to a surface at a given point (<a class="reference internal" href="#normal-vector-figure"><span class="std std-numref">Fig. 7.7</span></a>).</p>
<figure class="align-default" id="normal-vector-figure">
<a class="reference internal image-reference" href="../_images/07_normal_vector.svg"><img alt="../_images/07_normal_vector.svg" src="../_images/07_normal_vector.svg" width="250" /></a>
<figcaption>
<p><span class="caption-number">Fig. 7.7 </span><span class="caption-text">The surface normal vector.</span><a class="headerlink" href="#normal-vector-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Since in computer graphics are surfaces are triangles, we can easily calculate a normal vector using a <a class="reference internal" href="04_vectors_and_matrices.html#cross-product-section"><span class="std std-ref">cross product</span></a>. If a triangle has vertices <span class="math notranslate nohighlight">\(\vec{v}_0\)</span>, <span class="math notranslate nohighlight">\(\vec{v}_1\)</span> and <span class="math notranslate nohighlight">\(\vec{v}_2\)</span> then the normal vector can be calculated using</p>
<div class="math notranslate nohighlight">
\[ \vec{n} = (\vec{v}_1 - \vec{v}_0) \times (\vec{v}_2 - \vec{v}_1). \]</div>
<p>A surface is said to be back facing it its normal vector is pointing away from the camera position. If we only render the front facing surfaces then, assuming the surfaces are opaque, we should not notice any difference and we have halved the number of surfaces the shader has to deal with (<a class="reference internal" href="#backface-culling-figure"><span class="std std-numref">Fig. 7.8</span></a>).</p>
<figure class="align-default" id="backface-culling-figure">
<a class="reference internal image-reference" href="../_images/07_backface_culling.svg"><img alt="../_images/07_backface_culling.svg" src="../_images/07_backface_culling.svg" width="300" /></a>
<figcaption>
<p><span class="caption-number">Fig. 7.8 </span><span class="caption-text">Back face culling removes surfaces with vectors pointing away from the camera.</span><a class="headerlink" href="#backface-culling-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>But how do we know if a surface is back facing? Consider <a class="reference internal" href="#back-facing-figure"><span class="std std-numref">Fig. 7.9</span></a> which shows a back facing surface.</p>
<figure class="align-default" id="back-facing-figure">
<a class="reference internal image-reference" href="../_images/07_Back_facing.svg"><img alt="../_images/07_Back_facing.svg" src="../_images/07_Back_facing.svg" width="400" /></a>
<figcaption>
<p><span class="caption-number">Fig. 7.9 </span><span class="caption-text">A back facing surface.</span><a class="headerlink" href="#back-facing-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Here <span class="math notranslate nohighlight">\(\vec{v}\)</span> is a vector pointing from the camera to a point on the surface. Recall that the <a class="reference internal" href="04_vectors_and_matrices.html#dot-product-section"><span class="std std-ref">dot product</span></a> is related to the angle between two vectors, i.e.,</p>
<div class="math notranslate nohighlight">
\[ \vec{n} \cdot \text{v} = | \vec{n} | | \vec{v} | \cos(\theta). \]</div>
<p>If we have a back facing surface then <span class="math notranslate nohighlight">\(\theta\)</span> is less than 90<span class="math notranslate nohighlight">\(^\circ\)</span> and <span class="math notranslate nohighlight">\(\cos(\theta)\)</span> is a positive number so</p>
<div class="math notranslate nohighlight">
\[\begin{align*}
  \vec{n} \cdot \text{v} &gt; 0.
\end{align*}\]</div>
<p>So to apply back face culling the vertex shader just has to calculate the dot product between the <span class="math notranslate nohighlight">\(\vec{n}\)</span> and <span class="math notranslate nohighlight">\(\vec{v}\)</span> vectors and if it is a positive number it ignores the surface from then on. To apply back face culling in OpenGL all we need to do is add the following code to the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function near where we invoke the depth testing.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Enable back face culling</span>
<span class="n">glEnable</span><span class="p">(</span><span class="n">GL_CULL_FACE</span><span class="p">);</span>
</pre></div>
</div>
<p>Compile and run your program and use the keyboard and mouse to put the camera inside a cube. You will now see that the back faces haven’t been rendered.</p>
</section>
<hr class="docutils" />
<section id="exercises">
<h2><span class="section-number">7.6. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>Change the <code class="docutils literal notranslate"><span class="pre">calculateMatrices()</span></code> Camera class method so that the camera position always has a <span class="math notranslate nohighlight">\(y\)</span> co-ordinate of 0, i.e., like a first person shooter game where the player cannot fly around the world.</p></li>
<li><p>Add the ability for the user to perform a jump by pressing the space bar. The jump should last for 1 second and the camera should follow a smooth arc. Hint: the function <span class="math notranslate nohighlight">\(y = \tt height \cdot \sin(\pi \cdot \tt time)\)</span> produces values of <span class="math notranslate nohighlight">\(y=0\)</span> when <span class="math notranslate nohighlight">\(\tt time = 0\)</span> or <span class="math notranslate nohighlight">\(\tt time = 1\)</span> and <span class="math notranslate nohighlight">\(y = \tt height\)</span> when <span class="math notranslate nohighlight">\(\tt time = 0.5\)</span>.</p></li>
<li><p>Write your own class called <code class="docutils literal notranslate"><span class="pre">MyLib</span></code> with static member functions for each of the functions you have used from the glm library (e.g., <code class="docutils literal notranslate"><span class="pre">lookAt()</span></code>) and make use of them to calculate the <code class="docutils literal notranslate"><span class="pre">model</span></code>, <code class="docutils literal notranslate"><span class="pre">view</span></code> and <code class="docutils literal notranslate"><span class="pre">projection</span></code> matrices (you may make use of <code class="docutils literal notranslate"><span class="pre">glm::mat4</span></code> and <code class="docutils literal notranslate"><span class="pre">glm::vec3</span></code> types).</p></li>
</ol>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./_pages"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="06_3D_worlds.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">6. </span>3D Worlds</p>
      </div>
    </a>
    <a class="right-next"
       href="08_Lighting.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">8. </span>Lighting</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-keyboard-input-to-move-the-camera">7.1. Using keyboard input to move the camera</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#getting-the-keyboard-input">7.1.1. Getting the keyboard input</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#controlling-the-speed-of-the-camera">7.2. Controlling the speed of the camera.</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#using-the-mouse-to-point-the-camera">7.3. Using the mouse to point the camera</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#yaw-pitch-and-roll">7.3.1. Yaw, pitch and roll</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pointing-the-camera">7.3.2. Pointing the camera</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#changing-the-field-of-view-angle-using-scroll-wheel">7.4. Changing the field of view angle using scroll wheel</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#back-face-culling">7.5. Back face culling</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">7.6. Exercises</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Dr Jon Shiach
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>