

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>5. Transformations &#8212; Computer Graphics Labs</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"vec": ["\\mathbf{#1}", 1]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'pages/05_transformations';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6. 3D Worlds" href="06_3D_worlds.html" />
    <link rel="prev" title="4. Vectors and Matrices" href="04_vectors_and_matrices.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.svg" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.svg" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Computer Graphics
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="01_intro_to_cpp.html">1. Introduction to C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_basic_shapes_in_OpenGL.html">2. Basic Shapes in OpenGL</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_textures.html">3. Textures</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_vectors_and_matrices.html">4. Vectors and Matrices</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">5. Transformations</a></li>
<li class="toctree-l1"><a class="reference internal" href="06_3D_worlds.html">6. 3D Worlds</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_Moving_the_camera.html">7. Moving the camera</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_Lighting.html">8. Lighting</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_Normal_mapping.html">9. Normal Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_Quaternions.html">10. Quaternions</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="A_Complex_numbers_and_quaternions.html">A. Complex Numbers and Quaternions</a></li>
<li class="toctree-l1"><a class="reference internal" href="B_Code.html">B. Code and Assets</a></li>
<li class="toctree-l1"><a class="reference internal" href="C_Glossary.html">C Glossary</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs/issues/new?title=Issue%20on%20page%20%2Fpages/05_transformations.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/pages/05_transformations.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Transformations</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#translation">5.1. Translation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#translation-in-opengl">5.1.1. Translation in OpenGL</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#scaling">5.2. Scaling</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#scaling-in-opengl">5.2.1. Scaling in OpenGL</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rotation">5.3. Rotation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rotation-in-opengl">5.3.1. Rotation in OpenGL</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#axis-angle-rotation">5.3.2. Axis-angle rotation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#composite-transformations">5.4. Composite transformations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#composite-transformations-in-opengl">5.4.1. Composite transformations in OpenGL</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#animating-objects">5.5. Animating objects</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">5.6. Exercises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#source-code">5.7. Source code</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="transformations">
<span id="transformations-section"></span><h1><span class="section-number">5. </span>Transformations<a class="headerlink" href="#transformations" title="Permalink to this heading">#</a></h1>
<p>Computer graphics requires that shapes are manipulated in space by moving the shapes, shrinking or stretching, rotating and reflection to name a few. We call these manipulations <strong>transformations</strong>. We need a convenient way of telling the computer how to apply our transformations and for this we make use of matrices (hence why we needed to revise them here).</p>
<p>Each transformation has an associated <strong>transformation matrix</strong> which we used to multiply the co-ordinates of our shapes to calculate the co-ordinates of the transformed shape. For example if <span class="math notranslate nohighlight">\(A\)</span> is a transformation matrix for a particular transformation and <span class="math notranslate nohighlight">\((x,y,z)\)</span> are the co-ordinates of a point then we apply the transformation using</p>
<div class="math notranslate nohighlight">
\[ (x',y',z') = (x, y, z) \cdot A. \]</div>
<p>where <span class="math notranslate nohighlight">\((x',y',z')\)</span> are the co-ordinates of the transformed point.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The co-ordinate system used by OpenGL is a <a href="https://en.wikipedia.org/wiki/Right-hand_rule" target="_blank">right-hand</a> 3D co-ordinate system (on your right hand the thumb represents the <span class="math notranslate nohighlight">\(x\)</span>-axis, the index finger the <span class="math notranslate nohighlight">\(y\)</span>-axis and the middle finger the <span class="math notranslate nohighlight">\(z\)</span>-axis) with the <span class="math notranslate nohighlight">\(x\)</span>-axis pointing to the right, the <span class="math notranslate nohighlight">\(y\)</span>-axis point upwards and the <span class="math notranslate nohighlight">\(z\)</span>-axis pointing out of the screen towards the user.</p>
<figure class="align-default" id="id1">
<a class="reference internal image-reference" href="../_images/05_opengl_axes.svg"><img alt="../_images/05_opengl_axes.svg" src="../_images/05_opengl_axes.svg" width="300" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.1 </span><span class="caption-text">The OpenGL co-ordinate system.</span><a class="headerlink" href="#id1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
<section id="translation">
<span id="translation-section"></span><h2><span class="section-number">5.1. </span>Translation<a class="headerlink" href="#translation" title="Permalink to this heading">#</a></h2>
<p>The <strong>translation</strong> transformation when applied to a set of points moves each point by the same amount. For example, consider the triangle in <a class="reference internal" href="#translation-figure"><span class="std std-numref">Fig. 5.2</span></a>, each of the vertices has been translated by the same <strong>translation vector</strong> <span class="math notranslate nohighlight">\(\vec{t}\)</span> which has that effect of moving the triangle.</p>
<figure class="align-default" id="translation-figure">
<a class="reference internal image-reference" href="../_images/05_translation.svg"><img alt="../_images/05_translation.svg" height="280" src="../_images/05_translation.svg" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.2 </span><span class="caption-text">Translation of a triangle by the translation vector <span class="math notranslate nohighlight">\(\vec{t}= (t_x, t_y)\)</span>.</span><a class="headerlink" href="#translation-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>A problem we have is that no transformation matrix exists for applying translation to the co-ordinates <span class="math notranslate nohighlight">\((x, y, z)\)</span>, e.g., we can’t find a matrix <span class="math notranslate nohighlight">\(T\)</span> such that</p>
<div class="math notranslate nohighlight">
\[(x, y, z) \cdot T = (x + t_x, y + t_y, z + t_z).\]</div>
<p id="homogeneous-coordinates-section">Don’t worry, all is not lost. We can use a trick where we use <a href="https://en.wikipedia.org/wiki/Homogeneous_coordinates" target="_blank"><strong>homogeneous</strong></a> co-ordinates instead. Homogeneous co-ordinates add another value, <span class="math notranslate nohighlight">\(w\)</span> say, to the <span class="math notranslate nohighlight">\((x, y, z)\)</span> co-ordinates (these are known as Cartesian co-ordinates) such that when the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> values are divided by <span class="math notranslate nohighlight">\(w\)</span> we get the Cartesian co-ordinates.</p>
<div class="math notranslate nohighlight">
\[\underbrace{(x, y, z, w)}_{\textsf{homogeneous}} \equiv \underbrace{\left( \frac{x}{w}, \frac{y}{w}, \frac{z}{w} \right)}_{\textsf{Cartesian}}.\]</div>
<p>So if we choose <span class="math notranslate nohighlight">\(w=1\)</span> then we can write the Cartesian co-ordinates <span class="math notranslate nohighlight">\((x, y, z)\)</span> as the homogeneous co-ordinates <span class="math notranslate nohighlight">\((x, y, z, 1)\)</span> (remember that 4-element vector with the additional 1 in our <a class="reference internal" href="02_basic_shapes_in_OpenGL.html#vertex-shader-section"><span class="std std-ref">vertex shader</span></a>?). So how does that help us with our elusive translation matrix? Well we can now represent translation as a <span class="math notranslate nohighlight">\(4 \times 4\)</span> matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
   (x, y, z, 1)
   \begin{pmatrix}
       1 &amp; 0 &amp; 0 &amp; 0 \\
       0 &amp; 1 &amp; 0 &amp; 0 \\
       0 &amp; 0 &amp; 1 &amp; 0 \\
       t_x &amp; t_y &amp; t_z &amp; 1
   \end{pmatrix} =
   (x + t_x, y + t_y, z + t_z, 1),
\end{align*}\end{split}\]</div>
<p>which is our desired translation. So the <strong>translation matrix</strong> for translating a set of points by the vector <span class="math notranslate nohighlight">\(\vec{t} = (t_x, t_y, t_z)\)</span> is</p>
<div class="math notranslate nohighlight" id="equation-eq-translation-matrix">
<span class="eqno">(5.1)<a class="headerlink" href="#equation-eq-translation-matrix" title="Permalink to this equation">#</a></span>\[\begin{split} T = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    t_x &amp; t_y &amp; t_z &amp; 1
\end{pmatrix}. \end{split}\]</div>
<section id="translation-in-opengl">
<h3><span class="section-number">5.1.1. </span>Translation in OpenGL<a class="headerlink" href="#translation-in-opengl" title="Permalink to this heading">#</a></h3>
<p>Now we know the mathematical theory behind applying a transformation lets apply it to OpenGL. First download and build the project files for this lab.</p>
<ol class="arabic simple">
<li><p>Go to <a href="https://github.com/jonshiach/Lab05_Transformations" target="_blank">https://github.com/jonshiach/Lab05_Transformations</a> and follow the instructions to download and build the project files.</p></li>
<li><p>Open the project file <code class="docutils literal notranslate"><span class="pre">Lab05_Transformations.sln</span></code> (or <code class="docutils literal notranslate"><span class="pre">Lab05_Transformations.xcodeproj</span></code> on macOS) set the <strong>Lab05_Transformations</strong> project as the startup project.</p>
<ul class="simple">
<li><p>Visual Studio: right-click on the <strong>Lab05_Transformations</strong> project and select <strong>Set as Startup Project</strong>.</p></li>
<li><p>Xcode: Click on the target select dropdown (to the right of the name of the project at the top of the window) and select <strong>Lab05_Transformations</strong> as the target.</p></li>
</ul>
</li>
<li><p>Build the project by pressing CTRL + B (or ⌘B on Xcode) which should build the project without errors. Run the executable by pressing F5 (or ⌘R on Xcode).</p></li>
</ol>
<p>If all has gone to plan you should be presented with our smiley texture from <a class="reference internal" href="03_textures.html#textures-section"><span class="std std-ref">Lab 3</span></a> applied to a rectangle.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/05_texture.png"><img alt="../_images/05_texture.png" src="../_images/05_texture.png" style="width: 500px;" /></a>
</figure>
<p>Lets translate the rectangle 0.5 to the right and 0.3 upwards (remember we are dealing with normlised device co-ordinates so the window co-ordinates are between -1 and 1). The transformation matrix to perform this translation is</p>
<div class="math notranslate nohighlight">
\[\begin{split} T = \begin{pmatrix}
    1 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0.5 &amp; 0.3 &amp; 0 &amp; 1
\end{pmatrix}. \end{split}\]</div>
<p>Add the following code to the <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> file before the do/while loop.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define the translation matrix</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
<span class="n">translate</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="n">translate</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;translate = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">transpose</span><span class="p">(</span><span class="n">translate</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>The output command is there to check we have defined the translation matrix correctly. You should see the following in the output terminal (the window hasn’t changed, we’ll do that in a minute).</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>translate = 
[[    1.000,    0.000,    0.000,    0.000]
 [    0.000,    1.000,    0.000,    0.000]
 [    0.000,    0.000,    1.000,    0.000]
 [    0.500,    0.300,    0.000,    1.000]]
</pre></div>
</div>
<p>We need a way of passing the <code class="docutils literal notranslate"><span class="pre">translate</span></code> matrix to the shader. Since we are going to be using multiple transformations we will define a <code class="docutils literal notranslate"><span class="pre">transformation</span></code> matrix (for now we set this equal to <code class="docutils literal notranslate"><span class="pre">translate</span></code>) and send it to the vertex shader using a <a class="reference internal" href="03_textures.html#uniforms-section"><span class="std std-ref">uniform</span></a>. Add the following code to your <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> file to define <code class="docutils literal notranslate"><span class="pre">transformation</span></code> and get the handle of the uniform.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate the transformation matrix</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">transformation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">translate</span><span class="p">;</span>
<span class="w"> </span>
<span class="c1">// Get the handle for the transformation matrix</span>
<span class="n">GLuint</span><span class="w"> </span><span class="n">transformationID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;transformation&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>We send the uniform to the vertex shader <strong>in the rendering loop</strong> just before we draw the triangles with the <code class="docutils literal notranslate"><span class="pre">glDrawArrays()</span></code> function. Since we have a 4 <span class="math notranslate nohighlight">\(\times\)</span> 4 matrix we need to use the <code class="docutils literal notranslate"><span class="pre">glUniformMatrix4fv()</span></code> function to do this.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Send our transformation matrix to the vertex shader</span>
<span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">transformationID</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">transformation</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
</pre></div>
</div>
<p>The four inputs of <code class="docutils literal notranslate"><span class="pre">glUniformMatrix4fv()</span></code> are:</p>
<ul class="simple">
<li><p>the handle of the uniform we are sending;</p></li>
<li><p>the number of matrices we have;</p></li>
<li><p>an OpenGL Boolean value that determines whether we want to transpose the matrix;</p></li>
<li><p>a pointer to the matrix.</p></li>
</ul>
<p>All we now have to do is modify the vertex shader to use the transformation matrix.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>

<span class="c1">// Input vertex data</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">textureCoords</span><span class="p">;</span>

<span class="c1">// Output data</span>
<span class="n">out</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">uv</span><span class="p">;</span>

<span class="c1">// Values that stay constant for the whole mesh</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">mat4</span><span class="w"> </span><span class="n">transformation</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Output vertex postion</span>
<span class="w">    </span><span class="n">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">transformation</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Output (u,v) co-ordinates</span>
<span class="w">    </span><span class="n">uv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec2</span><span class="p">(</span><span class="n">textureCoords</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The only thing we’ve changed here is specify that we are passing the <code class="docutils literal notranslate"><span class="pre">transformation</span></code> matrix via a uniform and we have multiplied the 4-element vector containing the homogeneous co-ordinates of the vertex by the <code class="docutils literal notranslate"><span class="pre">transformation</span></code> matrix (remember that we reverse the order of the matrix multiplication in OpenGL). Compile and run the program and you should see that our rectangle has been translated to the right and up a bit.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/05_translation.png"><img alt="../_images/05_translation.png" src="../_images/05_translation.png" style="width: 500px;" /></a>
</figure>
<p>If you are having difficulty getting this to work take a look at <a class="reference download internal" download="" href="../_downloads/cfc377d90145dd3d168dbdc2b6abd74f/main.cpp"><span class="xref download myst">main.cpp</span></a> and <a class="reference download internal" download="" href="../_downloads/190b17b6b486c301279d23e0c2b1f2ca/vertexShader.vert"><span class="xref download myst">vertexShader.vert</span></a>.</p>
<p>Whilst it wasn’t particularly difficult to define the <code class="docutils literal notranslate"><span class="pre">translate</span></code> matrix it is something it is a common operation so the glm function <code class="docutils literal notranslate"><span class="pre">glm::translate(matrix,</span> <span class="pre">vector)</span></code> outputs the translation matrix for the translation by <code class="docutils literal notranslate"><span class="pre">vector</span></code> applied to <code class="docutils literal notranslate"><span class="pre">matrix</span></code>. So we can replace the line of code where we calculated <code class="docutils literal notranslate"><span class="pre">translate</span></code> with the following</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">translate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w">                 </span><span class="c1">// matrix that translation is being applied to</span>
<span class="w">                           </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">));</span><span class="w">    </span><span class="c1">// translation vector (tx, ty, tz)</span>
</pre></div>
</div>
<p>The first input to the <code class="docutils literal notranslate"><span class="pre">glm::translate()</span></code> function is the matrix we want to apply the translation to (here we have used the identity matrix) and the second input is the 3-element translation vector.</p>
</section>
</section>
<section id="scaling">
<h2><span class="section-number">5.2. </span>Scaling<a class="headerlink" href="#scaling" title="Permalink to this heading">#</a></h2>
<p>Scaling is the simplest transformation we can apply. Multiplying the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> co-ordinates of a point by a scalar quantity (a number) has the effect of moving the point closer or further away from the origin (0,0). For example, consider the triangle in <a class="reference internal" href="#scaling-about-origin-figure"><span class="std std-numref">Fig. 5.3</span></a>. The <span class="math notranslate nohighlight">\(x\)</span> co-ordinate of each vertex has been multiplied by <span class="math notranslate nohighlight">\(s_x\)</span> and the <span class="math notranslate nohighlight">\(y\)</span> co-ordinates have been multiplied by <span class="math notranslate nohighlight">\(s_y\)</span> which has the effect of scaling the triangle and moving the vertices further away from the origin (in this case <span class="math notranslate nohighlight">\(s_x\)</span> and <span class="math notranslate nohighlight">\(s_y\)</span> are both greater than 1).</p>
<figure class="align-default" id="scaling-about-origin-figure">
<a class="reference internal image-reference" href="../_images/05_scaling.svg"><img alt="../_images/05_scaling.svg" height="350" src="../_images/05_scaling.svg" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.3 </span><span class="caption-text">Scaling a triangle centred at the origin.</span><a class="headerlink" href="#scaling-about-origin-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Since scaling is simply multiplying the co-ordinates by a number we have</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    (x, y, z, 1) 
    \begin{pmatrix} 
        s_x &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; s_y &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; s_z &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 1 
    \end{pmatrix}
    = (s_xx, s_yy, s_zz, 1),
\end{align*} \end{split}\]</div>
<p>so the <strong>scaling matrix</strong> for applying the scaling transformation is</p>
<div class="math notranslate nohighlight" id="equation-eq-scaling-matrix">
<span class="eqno">(5.2)<a class="headerlink" href="#equation-eq-scaling-matrix" title="Permalink to this equation">#</a></span>\[\begin{split} S = 
\begin{pmatrix} 
    s_x &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; s_y &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; s_z &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}. \end{split}\]</div>
<section id="scaling-in-opengl">
<h3><span class="section-number">5.2.1. </span>Scaling in OpenGL<a class="headerlink" href="#scaling-in-opengl" title="Permalink to this heading">#</a></h3>
<p>Lets now apply scaling to our rectangle in OpenGL to increase its size by a factor of 2 and 1.5 in the <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> directions respectively. The process is very similar to how we did the translation and since we have already created a uniform, passed it to the vertex shader and modified the vertex shader, all we need to do to apply shading is calculate the shading matrix. The scaling matrix for doubling the size of the rectangle is</p>
<div class="math notranslate nohighlight">
\[\begin{split} S = \begin{pmatrix}
    2 &amp; 0 &amp; 0 &amp; 0 \\
    0 &amp; 1.5 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}.\end{split}\]</div>
<p>Define the scaling matrix using the code below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Scaling matrix</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
<span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.5f</span><span class="p">;</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">scale = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">transpose</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>Also, set the <code class="docutils literal notranslate"><span class="pre">transformation</span></code> matrix equal to the <code class="docutils literal notranslate"><span class="pre">scale</span></code> matrix.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">transformation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
</pre></div>
</div>
<p>Compiling and running the program should output the <code class="docutils literal notranslate"><span class="pre">scale</span></code> matrix so we can check this is correct and present use with our textured rectangle now twice the size it was originally.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>scale = 
[[    2.000,    0.000,    0.000,    0.000]
 [    0.000,    1.500,    0.000,    0.000]
 [    0.000,    0.000,    1.000,    0.000]
 [    0.000,    0.000,    0.000,    1.000]]
</pre></div>
</div>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/05_scaling.png"><img alt="../_images/05_scaling.png" src="../_images/05_scaling.png" style="width: 500px;" /></a>
</figure>
<p>As with the translation matrix, glm has the function <code class="docutils literal notranslate"><span class="pre">glm::scale()</span></code> which returns a scaling matrix. Replace the line of code where we calculated the <code class="docutils literal notranslate"><span class="pre">scale</span></code> matrix is the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w">               </span><span class="c1">// matrix that scaling is applied to</span>
<span class="w">                   </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">));</span><span class="w">  </span><span class="c1">// scaling factors (sx, sy, sz)</span>
</pre></div>
</div>
<p>If you compile and run the program you will notice nothing has changed.</p>
</section>
</section>
<section id="rotation">
<span id="rotation-section"></span><h2><span class="section-number">5.3. </span>Rotation<a class="headerlink" href="#rotation" title="Permalink to this heading">#</a></h2>
<p>As well as translating and scaling objects, the next most common transformation is the rotation of objects around the three co-ordinate axes <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span>. We define the rotation <strong>anti-clockwise</strong> around each of the co-ordinate axes by an angle <span class="math notranslate nohighlight">\(\theta\)</span> when looking down the axes (<a class="reference internal" href="#d-rotation-figure"><span class="std std-numref">Fig. 5.4</span></a>).</p>
<figure class="align-default" id="d-rotation-figure">
<a class="reference internal image-reference" href="../_images/05_3D_rotation.svg"><img alt="../_images/05_3D_rotation.svg" height="350" src="../_images/05_3D_rotation.svg" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.4 </span><span class="caption-text">Rotation is assumed to be in the anti-clockwise direction when looking down the axis.</span><a class="headerlink" href="#d-rotation-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The <strong>rotation matrices</strong> for achieving these rotations are</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    R_x &amp;= 
    \begin{pmatrix} 
        1 &amp; 0 &amp; 0 &amp; 0 \\ 
        0 &amp; \cos(\theta) &amp; \sin(\theta) &amp; 0 \\
        0 &amp; -\sin(\theta) &amp; \cos(\theta) &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}, \\
    R_y &amp;= 
    \begin{pmatrix} 
        \cos(\theta) &amp; 0 &amp; -\sin(\theta) &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 \\
        \sin(\theta) &amp; 0 &amp; \cos(\theta) &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}, \\
    R_z &amp;= 
    \begin{pmatrix} 
        \cos(\theta) &amp; \sin(\theta) &amp; 0 &amp; 0 \\
        -\sin(\theta) &amp; \cos(\theta) &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 1 &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}.
\end{align*} \end{split}\]</div>
<p>You don’t really need to know how these are derived but if you are curious you can click on the dropdown link below.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Derivation of the rotation matrices (click to show)<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text">We will consider rotation about the <span class="math notranslate nohighlight">\(z\)</span>-axis and will restrict our co-ordinates to 2D.</p>
<figure class="align-default" id="rotation-figure">
<a class="reference internal image-reference" href="../_images/05_rotation.svg"><img alt="../_images/05_rotation.svg" height="300" src="../_images/05_rotation.svg" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.5 </span><span class="caption-text">Rotating the vector <span class="math notranslate nohighlight">\(\vec{u}\)</span> anti-clockwise by angle <span class="math notranslate nohighlight">\(\theta\)</span> to the vector <span class="math notranslate nohighlight">\(\vec{v}\)</span>.</span><a class="headerlink" href="#rotation-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p class="sd-card-text">Consider <a class="reference internal" href="#rotation-figure"><span class="std std-numref">Fig. 5.5</span></a> where the vector <span class="math notranslate nohighlight">\(\vec{u}\)</span> is rotated by angle <span class="math notranslate nohighlight">\(\theta\)</span> to the vector <span class="math notranslate nohighlight">\(\vec{v}\)</span>. To get this rotation we first consider the rotation of the vector <span class="math notranslate nohighlight">\(\vec{t}\)</span>, which has the same length as <span class="math notranslate nohighlight">\(\vec{u}\)</span> and points along the <span class="math notranslate nohighlight">\(x\)</span>-axis, by angle <span class="math notranslate nohighlight">\(\phi\)</span> to get to <span class="math notranslate nohighlight">\(\vec{u}\)</span>. If we form a right-angled triangle (the blue one) then we know the length of the hypotenuse, <span class="math notranslate nohighlight">\(|\vec{u}|\)</span>, and the angle so we can calculate the lengths of the adjacent and opposite sides using trigonometry. Remember our trig ratios (SOH-CAH-TOA)</p>
<div class="math notranslate nohighlight">
\[ \begin{align*}
    \sin(\phi) &amp;= \frac{\textsf{opposite}}{\textsf{hypotenuse}}, &amp;
    \cos(\phi) &amp;= \frac{\textsf{adjacent}}{\textsf{hypotenuse}}, &amp;
    \tan(\phi) &amp;= \frac{\textsf{opposite}}{\textsf{adjacent}},
\end{align*} \]</div>
<p class="sd-card-text">so the length of the adjacent and opposite sides of the blue triangle is</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \textsf{adjacent} &amp;= \textsf{hypotenuse} \cdot \cos(\phi), \\
    \textsf{opposite} &amp;= \textsf{hypotenuse} \cdot \sin(\phi).
\end{align*} \end{split}\]</div>
<p class="sd-card-text">Now <span class="math notranslate nohighlight">\(u_x\)</span> and <span class="math notranslate nohighlight">\(u_y\)</span> are the lengths of the adjacent and opposite sides respectively and <span class="math notranslate nohighlight">\(|\vec{u}|\)</span> is the length of the hypotenuse so we have</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    u_x &amp;= |\vec{u}| \cos(\phi), \\
    u_y &amp;= |\vec{u}| \sin(\phi).
\end{align*} \end{split}\]</div>
<p class="sd-card-text">Now consider the rotation from <span class="math notranslate nohighlight">\(\vec{t}\)</span> by the angle <span class="math notranslate nohighlight">\(\phi + \theta\)</span> to get to <span class="math notranslate nohighlight">\(\vec{v}\)</span>. Using the same method as before we have</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    v_x &amp;= |\vec{u}| \cos(\phi + \theta), \\
    v_y &amp;= |\vec{u}| \sin(\phi + \theta).
\end{align*} \end{split}\]</div>
<p class="sd-card-text">We can rewrite <span class="math notranslate nohighlight">\(\cos(\phi+\theta)\)</span> and <span class="math notranslate nohighlight">\(\sin(\phi+\theta)\)</span> using <a href="https://en.wikipedia.org/wiki/List_of_trigonometric_identities#" target="_blank">trigonometric identities</a></p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \cos(\phi + \theta) &amp;= \cos(\phi) \cos(\theta) - \sin(\phi) \sin(\theta), \\
    \sin(\phi + \theta) &amp;= \sin(\phi) \cos(\theta) + \cos(\phi) \sin(\theta),
\end{align*} \end{split}\]</div>
<p class="sd-card-text">so</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    v_x &amp;= |\vec{u}| \cos(\phi) \cos(\theta) - |\vec{u}| \sin(\phi) \sin(\theta), \\
    v_y &amp;= |\vec{u}| \sin(\phi) \cos(\theta) + |\vec{u}| \cos(\phi) \sin(\theta).
\end{align*} \end{split}\]</div>
<p class="sd-card-text">Since <span class="math notranslate nohighlight">\( u_x = |\vec{u}| \cos(\phi)\)</span> and <span class="math notranslate nohighlight">\(u_y = |\vec{u}| \sin(\phi)\)</span> then</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    v_x &amp;= u_x \cos(\theta) - u_y \sin(\theta), \\
    v_y &amp;= u_y \sin(\phi) + u_x \sin(\theta),
\end{align*} \end{split}\]</div>
<p class="sd-card-text">which can be written using matrices as</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \begin{pmatrix} v_x &amp; v_y \end{pmatrix} =
    \begin{pmatrix} u_x &amp; u_y \end{pmatrix}
    \begin{pmatrix} \cos(\theta) &amp; \sin(\theta) \\ -\sin(\theta) &amp; \cos(\theta) \end{pmatrix},
\end{align*} \end{split}\]</div>
<p class="sd-card-text">so the transformation matrix for rotating around the <span class="math notranslate nohighlight">\(z\)</span>-axis in 2D is</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{pmatrix} \cos(\theta) &amp; \sin(\theta) \\ -\sin(\theta) &amp; \cos(\theta) \end{pmatrix}. \end{split}\]</div>
<p class="sd-card-text">We need a <span class="math notranslate nohighlight">\(4\times 4\)</span> matrix to represent 3D rotation around the <span class="math notranslate nohighlight">\(z\)</span>-axis so we replace the 3rd and 4th row and columns with the 3rd and 4th row and column from the <span class="math notranslate nohighlight">\(4\times 4\)</span> identity matrix giving</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{pmatrix} 
    \cos(\theta) &amp; \sin(\theta) &amp; 0 &amp; 0 \\
    -\sin(\theta) &amp; \cos(\theta) &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}. \end{split}\]</div>
<p class="sd-card-text">The rotation matrices for the rotation around the <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> axes are derived using a similar process.</p>
</div>
</details><div class="admonition note">
<p class="admonition-title">Note</p>
<p>You may find some sources present the rotation matrices in a slightly different way where the negative sign for <span class="math notranslate nohighlight">\(\sin(\theta)\)</span> is swapped (see <a href="https://en.wikipedia.org/wiki/Rotation_matrix" target="_blank">Wikipedia</a> for an example). This is because these assume that the vertices are multiplied by the transformation matrix on the left, e.g., <span class="math notranslate nohighlight">\((x', y', z', 1)^\mathsf{T} = T\cdot (x, y, z, 1)^\mathsf{T}\)</span>. With OpenGL we multiply by the transformation matrix on the right, e.g., <span class="math notranslate nohighlight">\((x', y', y', 1) = (x, y, z, 1) \cdot T\)</span> so our rotation matrices are the transpose of those given elsewhere (although of course in our code we use <code class="docutils literal notranslate"><span class="pre">T</span> <span class="pre">*</span> <span class="pre">[x,</span> <span class="pre">y,</span> <span class="pre">z,</span> <span class="pre">1]</span></code> since OpenGL uses column-major order to store the matrices - this can get quite confusing!).</p>
</div>
<section id="rotation-in-opengl">
<h3><span class="section-number">5.3.1. </span>Rotation in OpenGL<a class="headerlink" href="#rotation-in-opengl" title="Permalink to this heading">#</a></h3>
<p>Lets rotate our original rectangle anti-clockwise about the <span class="math notranslate nohighlight">\(z\)</span>-axis by <span class="math notranslate nohighlight">\(\theta = 45^\circ\)</span>. The rotation matrix to do this is</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{pmatrix}
    \cos(45^\circ) &amp; \sin(45^\circ) &amp; 0 &amp; 0 \\
    -\sin(45^\circ) &amp; \cos(45^\circ) &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix} =
\begin{pmatrix}
    0.707 &amp; 0.707 &amp; 0 &amp; 0 \\
    -0.707 &amp; 0.707 &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}. \end{split}\]</div>
<p>Define the rotation matrix using the code below.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define rotation matrix</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
<span class="kt">float</span><span class="w"> </span><span class="n">angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">45.0f</span><span class="p">);</span>
<span class="n">rotate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="w">  </span><span class="n">rotate</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">);</span>
<span class="n">rotate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">),</span><span class="w"> </span><span class="n">rotate</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">rotate = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">transpose</span><span class="p">(</span><span class="n">rotate</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
</pre></div>
</div>
<p>Note that here we needed to convert 45<span class="math notranslate nohighlight">\(^\circ\)</span> into <a href="https://en.wikipedia.org/wiki/Radian" target="_blank"><strong>radians</strong></a> since OpenGL expects angles to be in radians. We now set the <code class="docutils literal notranslate"><span class="pre">transformation</span></code> matrix equal to our <code class="docutils literal notranslate"><span class="pre">rotate</span></code> matrix</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">transformation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rotate</span><span class="p">;</span>
</pre></div>
</div>
<p>Compiling and running the program should output the <code class="docutils literal notranslate"><span class="pre">rotate</span></code> matrix to the terminal so we can check this is correct and we can see in our application window that the textured rectangle has been rotated 45<span class="math notranslate nohighlight">\(^\circ\)</span> in the anti-clockwise direction.</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>rotate = 
[[    0.707,    0.707,    0.000,    0.000]
 [   -0.707,    0.707,    0.000,    0.000]
 [    0.000,    0.000,    1.000,    0.000]
 [    0.000,    0.000,    0.000,    1.000]]
</pre></div>
</div>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/05_rotation.png"><img alt="../_images/05_rotation.png" src="../_images/05_rotation.png" style="width: 500px;" /></a>
</figure>
</section>
<section id="axis-angle-rotation">
<span id="axis-angle-rotation-section"></span><h3><span class="section-number">5.3.2. </span>Axis-angle rotation<a class="headerlink" href="#axis-angle-rotation" title="Permalink to this heading">#</a></h3>
<p>The three rotation transformations are only useful if we want to only rotate around one of the three co-ordinate axes. A more useful transformation is the rotation around the axis that points in the direction of a vector, <span class="math notranslate nohighlight">\(\vec{v}\)</span> say, which has its tail at (0,0,0) (<a class="reference internal" href="#axis-angle-rotation-figure"><span class="std std-numref">Fig. 5.6</span></a>).</p>
<figure class="align-default" id="axis-angle-rotation-figure">
<a class="reference internal image-reference" href="../_images/05_axis_angle_rotation_1.svg"><img alt="../_images/05_axis_angle_rotation_1.svg" height="250" src="../_images/05_axis_angle_rotation_1.svg" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.6 </span><span class="caption-text">Axis-angle rotation.</span><a class="headerlink" href="#axis-angle-rotation-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The transformation matrix for rotation around a <strong>unit vector</strong> <span class="math notranslate nohighlight">\(\hat{\vec{v}} = (v_x, v_y, v_z)\)</span>, anti-clockwise by angle <span class="math notranslate nohighlight">\(\theta\)</span> when looking down the vector is.</p>
<div class="math notranslate nohighlight" id="equation-eq-axis-angle-rotation-matrix">
<span class="eqno">(5.3)<a class="headerlink" href="#equation-eq-axis-angle-rotation-matrix" title="Permalink to this equation">#</a></span>\[\begin{split} \begin{align*}
    R =
    \begin{pmatrix}
        v_x^2 (1 - \cos(\theta)) + \cos(\theta) &amp;
        v_x v_y (1 - \cos(\theta)) + v_z\sin(\theta) &amp;
        v_x v_z (1 - \cos(\theta)) - v_y\sin(\theta) &amp;
        0 \\
        v_y v_x (1 - \cos(\theta)) - v_z\sin(\theta) &amp;
        v_y^2 (1 - \cos(\theta)) + \cos(\theta) &amp;
        v_y v_z (1 - \cos(\theta)) + v_x\sin(\theta) &amp;
        0 \\
        v_z v_x (1 - \cos(\theta)) + v_y\sin(\theta) &amp;
        v_z v_y (1 - \cos(\theta)) - v_x\sin(\theta) &amp;
        v_z^2 (1 - \cos(\theta)) + \cos(\theta) &amp;
        0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}
\end{align*} \end{split}\]</div>
<p>Again, you don’t really need to know how this is derived but if you are curious click on the dropdown link below.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Derivation of the axis-angle rotation matrix (click to show)<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text">The rotation about the vector <span class="math notranslate nohighlight">\(\vec{v} = (v_x, v_y, v_z)\)</span> by angle <span class="math notranslate nohighlight">\(\theta\)</span> is the <a class="reference internal" href="#composite-transformations-section"><span class="std std-ref">composition</span></a> of 5 separate rotations:</p>
<ol class="arabic simple">
<li><p class="sd-card-text">Rotate <span class="math notranslate nohighlight">\(\vec{v}\)</span> around the <span class="math notranslate nohighlight">\(x\)</span>-axis so that it is in the <span class="math notranslate nohighlight">\(xz\)</span>-plane (the <span class="math notranslate nohighlight">\(y\)</span> component of the vector is 0);</p></li>
<li><p class="sd-card-text">Rotate the vector around the <span class="math notranslate nohighlight">\(y\)</span>-axis so that it points along the <span class="math notranslate nohighlight">\(z\)</span>-axis (the <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> components are 0 and the <span class="math notranslate nohighlight">\(z\)</span> component is a positive number);</p></li>
<li><p class="sd-card-text">Perform the rotation around the <span class="math notranslate nohighlight">\(z\)</span>-axis;</p></li>
<li><p class="sd-card-text">Reverse the rotation around the <span class="math notranslate nohighlight">\(y\)</span>-axis;</p></li>
<li><p class="sd-card-text">Reverse the rotation around the <span class="math notranslate nohighlight">\(x\)</span>-axis.</p></li>
</ol>
<p class="sd-card-text">The rotation around the <span class="math notranslate nohighlight">\(x\)</span>-axis is achieved by forming a right-angled triangle in the <span class="math notranslate nohighlight">\(yz\)</span>-plane where the the angle of rotation <span class="math notranslate nohighlight">\(\theta\)</span> has an adjacent side of length <span class="math notranslate nohighlight">\(v_z\)</span>, an opposite side of length <span class="math notranslate nohighlight">\(v_y\)</span> and a hypotenuse of length <span class="math notranslate nohighlight">\(\sqrt{v_y^2 + v_z^2}\)</span> (<a class="reference internal" href="#axis-angle-rotation1-figure"><span class="std std-numref">Fig. 5.7</span></a>).</p>
<figure class="align-default" id="axis-angle-rotation1-figure">
<a class="reference internal image-reference" href="../_images/05_axis_angle_rotation_2.svg"><img alt="../_images/05_axis_angle_rotation_2.svg" height="220" src="../_images/05_axis_angle_rotation_2.svg" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.7 </span><span class="caption-text">Rotate <span class="math notranslate nohighlight">\(\vec{v}\)</span> around the <span class="math notranslate nohighlight">\(x\)</span>-axis</span><a class="headerlink" href="#axis-angle-rotation1-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p class="sd-card-text">Therefore <span class="math notranslate nohighlight">\(\cos(\theta) = \dfrac{v_z}{\sqrt{v_y^2 + v_z^2}}\)</span> and <span class="math notranslate nohighlight">\(\sin(\theta) = \dfrac{v_y}{\sqrt{v_y^2 + v_z^2}}\)</span> so the rotation matrix is</p>
<div class="math notranslate nohighlight">
\[\begin{split} R_1 = \begin{pmatrix} 
    1 &amp; 0 &amp; 0 &amp; 0 \\ 
    0 &amp; \dfrac{v_z}{\sqrt{v_y^2 + v_z^2}} &amp; \dfrac{v_y}{\sqrt{v_y^2 + v_z^2}} &amp; 0 \\
    0 &amp; -\dfrac{v_x}{\sqrt{v_y^2 + v_z^2}} &amp; \dfrac{v_z}{\sqrt{v_y^2 + v_z^2}} &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}.\end{split}\]</div>
<p class="sd-card-text">The rotation around the <span class="math notranslate nohighlight">\(y\)</span>-axis is achieved by forming another right-angled triangle in the <span class="math notranslate nohighlight">\(xz\)</span>-plane where <span class="math notranslate nohighlight">\(\theta\)</span> has an adjacent side of length <span class="math notranslate nohighlight">\(\sqrt{v_y^2 + v_z^2}\)</span>, an opposite side of length <span class="math notranslate nohighlight">\(v_x\)</span> and a hypotenuse of length <span class="math notranslate nohighlight">\(|\vec{v}|\)</span> (<a class="reference internal" href="#axis-angle-rotation2-figure"><span class="std std-numref">Fig. 5.8</span></a>).</p>
<figure class="align-default" id="axis-angle-rotation2-figure">
<a class="reference internal image-reference" href="../_images/05_axis_angle_rotation_3.svg"><img alt="../_images/05_axis_angle_rotation_3.svg" height="250" src="../_images/05_axis_angle_rotation_3.svg" /></a>
<figcaption>
<p><span class="caption-number">Fig. 5.8 </span><span class="caption-text">Rotate around the <span class="math notranslate nohighlight">\(y\)</span>-axis</span><a class="headerlink" href="#axis-angle-rotation2-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p class="sd-card-text">Therefore <span class="math notranslate nohighlight">\(\cos(\theta) = \dfrac{\sqrt{v_y^2 + v_z^2}}{|\vec{v}|}\)</span> and <span class="math notranslate nohighlight">\(\sin(\theta) = \dfrac{v_x}{|\vec{v}|}\)</span>. Note that here we are rotating in the clockwise direction so the rotation matrix is</p>
<div class="math notranslate nohighlight">
\[\begin{split} R_2 = \begin{pmatrix} 
    \dfrac{\sqrt{v_y^2 + v_z^2}}{|\vec{v}|} &amp; 0 &amp; \dfrac{v_x}{|\vec{v}|} &amp; 0 \\
    0 &amp; 1 &amp; 0 &amp; 0 \\
    -\dfrac{v_x}{|\vec{v}|} &amp; 0 &amp; \dfrac{\sqrt{v_y^2 + v_z^2}}{|\vec{v}|} &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}.\end{split}\]</div>
<p class="sd-card-text">Now that the vector points along the <span class="math notranslate nohighlight">\(z\)</span>-axis we perform the rotation so the rotation matrix for this is</p>
<div class="math notranslate nohighlight">
\[\begin{split} R_3 = \begin{pmatrix}
    \cos(\theta) &amp; \sin(\theta) &amp; 0 &amp; 0 \\
    -\sin(\theta) &amp; \cos(\theta) &amp; 0 &amp; 0 \\
    0 &amp; 0 &amp; 1 &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}. \end{split}\]</div>
<p class="sd-card-text">The reverse rotation around the <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(x\)</span> axes is simply the rotation matrices <span class="math notranslate nohighlight">\(R_2\)</span> and <span class="math notranslate nohighlight">\(R_1\)</span> with the negative sign for the <span class="math notranslate nohighlight">\(\sin(\theta)\)</span> swapped</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    R_4 &amp;= \begin{pmatrix} 
       \dfrac{\sqrt{v_y^2 + v_z^2}}{|\vec{v}|} &amp; 0 &amp; -\dfrac{v_x}{|\vec{v}|} &amp; 0 \\
       0 &amp; 1 &amp; 0 &amp; 0 \\
       \dfrac{v_x}{|\vec{v}|} &amp; 0 &amp; \dfrac{\sqrt{v_y^2 + v_z^2}}{|\vec{v}|} &amp; 0 \\
       0 &amp; 0 &amp; 0 &amp; 1
   \end{pmatrix}, \\
   R_5 &amp;= \begin{pmatrix} 
       1 &amp; 0 &amp; 0 &amp; 0 \\ 
       0 &amp; \dfrac{v_z}{\sqrt{v_y^2 + v_z^2}} &amp; -\dfrac{v_y}{\sqrt{v_y^2 + v_z^2}} &amp; 0 \\
       0 &amp; \dfrac{v_x}{\sqrt{v_y^2 + v_z^2}} &amp; \dfrac{v_z}{\sqrt{v_y^2 + v_z^2}} &amp; 0 \\
       0 &amp; 0 &amp; 0 &amp; 1
   \end{pmatrix}.
\end{align*} \end{split}\]</div>
<p class="sd-card-text">Multiplying all of the separate matrices together gives</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    R &amp;= R_1 \cdot R_2 \cdot R_3 \cdot R_4 \cdot R_5 \\
    &amp;=
    \begin{pmatrix}
        \dfrac{v_x^2 + (v_y^2 + v_z^2) \cos(\theta)}{|\vec{v}|^2} &amp;
        \dfrac{v_xv_y(1 - \cos(\theta))}{|\vec{v}|^2} + \dfrac{v_z\sin(\theta)}{|\vec{v}|} &amp;
        \dfrac{v_xv_z(1 - \cos(\theta))}{|\vec{v}|^2} - \dfrac{v_y\sin(\theta)}{|\vec{v}|} &amp; 
        0 \\
        \dfrac{v_xv_y(1 - \cos(\theta))}{|\vec{v}|^2} - \dfrac{v_z\sin(\theta)}{|\vec{v}|} &amp;
        \dfrac{v_y^2 + (v_x^2 + v_y^2)\cos(\theta)}{|\vec{v}|^2} &amp;
        \dfrac{v_yv_z(1 - \cos(\theta))}{|\vec{v}|^2} - \dfrac{v_x\sin(\theta)}{|\vec{v}|} &amp;
        0 \\
        \dfrac{v_xv_z(1 - \cos(\theta))}{|\vec{v}|^2} + \dfrac{v_y\sin(\theta)}{|\vec{v}|} &amp;
        \dfrac{v_yv_z(1 - \cos(\theta))}{|\vec{v}|^2} - \dfrac{v_x\sin(\theta)}{|\vec{v}|} &amp;
        \dfrac{v_z^2 + (v_x^2 + v_y^2)\cos(\theta)}{|\vec{v}|^2} &amp; 
        0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}
\end{align*} \end{split}\]</div>
<p class="sd-card-text">If we make <span class="math notranslate nohighlight">\(\vec{v}\)</span> a unit vector so that <span class="math notranslate nohighlight">\(|\vec{v}| = 1\)</span> and <span class="math notranslate nohighlight">\(v_y^2 + v_z^2 = 1 - v_x^2\)</span> then this simplifies to</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    R =
    \begin{pmatrix}
        v_x^2 (1 - \cos(\theta)) + \cos(\theta) &amp;
        v_x v_y (1 - \cos(\theta)) + v_z\sin(\theta) &amp;
        v_x v_z (1 - \cos(\theta)) - v_y\sin(\theta) &amp;
        0 \\
        v_y v_x (1 - \cos(\theta)) - v_z\sin(\theta) &amp;
        v_y^2 (1 - \cos(\theta)) + \cos(\theta) &amp;
        v_y v_z (1 - \cos(\theta)) + v_x\sin(\theta) &amp;
        0 \\
        v_z v_x (1 - \cos(\theta)) + v_y\sin(\theta) &amp;
        v_z v_y (1 - \cos(\theta)) - v_x\sin(\theta) &amp;
        v_z^2 (1 - \cos(\theta)) + \cos(\theta) &amp;
        0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}
\end{align*} \end{split}\]</div>
</div>
</details><p>Fortunately we do not need to code this matrix into C++ as glm has a function to calculate the axis-angle rotation. The function is <code class="docutils literal notranslate"><span class="pre">glm::rotate(matrix,</span> <span class="pre">angle,</span> <span class="pre">vector)</span></code> where <code class="docutils literal notranslate"><span class="pre">angle</span></code> is in radians and <code class="docutils literal notranslate"><span class="pre">vector</span></code> is the direction vector which were are rotating around. Replace the two lines of code where we have defined the <code class="docutils literal notranslate"><span class="pre">rotate</span></code> matrix with the following</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">rotate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w">               </span><span class="c1">// matrix that rotation is applied to</span>
<span class="w">                     </span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">45.0f</span><span class="p">),</span><span class="w">           </span><span class="c1">// rotation angle</span>
<span class="w">                     </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">));</span><span class="w">  </span><span class="c1">// vector to rotate around</span>
</pre></div>
</div>
<p>Here we have used the vector (0, 0, 1) as we wanted to rotate around the <span class="math notranslate nohighlight">\(z\)</span>-axis. You should see no change in the output.</p>
</section>
</section>
<section id="composite-transformations">
<span id="composite-transformations-section"></span><h2><span class="section-number">5.4. </span>Composite transformations<a class="headerlink" href="#composite-transformations" title="Permalink to this heading">#</a></h2>
<p>So far we have performed translation, scaling and rotation transformations on our rectangle separately. What if we wanted to combine these transformations so that we can control the size, rotation and position of the rectangle? If <span class="math notranslate nohighlight">\(T\)</span>, <span class="math notranslate nohighlight">\(S\)</span> and <span class="math notranslate nohighlight">\(R\)</span> are the transformation matrices for translation, scaling and rotation, then if we want to scale first, then rotate and then translate the scaled object we have</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    (x', y', z', 1) &amp;= (((x, y, z, 1) \cdot S) \cdot R) \cdot T \\
    &amp;= (x, y, z, 1) \cdot (S \cdot R \cdot T)
\end{align*} \end{split}\]</div>
<p><span class="math notranslate nohighlight">\(S \cdot R \cdot T\)</span> is a single <span class="math notranslate nohighlight">\(4 \times 4\)</span> transformation matrix that combines the three transformations known as the <strong>composite transformation matrix</strong>.</p>
<section id="composite-transformations-in-opengl">
<h3><span class="section-number">5.4.1. </span>Composite transformations in OpenGL<a class="headerlink" href="#composite-transformations-in-opengl" title="Permalink to this heading">#</a></h3>
<p>Lets apply scaling, rotation and translation (in that order) to our rectangle. Since we have already calculated the separate transformation matrices all we need to do is to multiply them together and set it equal to <code class="docutils literal notranslate"><span class="pre">transformation</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">transformation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
</pre></div>
</div>
<div class="admonition important" id="column-major-important-note">
<p class="admonition-title">Important</p>
<p>Remember that OpenGL and glm use column-major ordering so we reverse the order of our matrices when multiplying. So <span class="math notranslate nohighlight">\(S \cdot R \cdot T\)</span> would be coded as</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">S</span>
</pre></div>
</div>
<p>i.e., the transformations are applied from right to left.</p>
</div>
<p>After compiling and running the program you should see the following.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/05_composite_transformation.png"><img alt="../_images/05_composite_transformation.png" src="../_images/05_composite_transformation.png" style="width: 500px;" /></a>
</figure>
</section>
</section>
<section id="animating-objects">
<span id="animating-objects-section"></span><h2><span class="section-number">5.5. </span>Animating objects<a class="headerlink" href="#animating-objects" title="Permalink to this heading">#</a></h2>
<p>It may appear that our application is displaying a static image of the textured rectangle but what is actually happing is that the window is constantly being updated with new frame buffers as and when they have been calculated. We can animate our rectangle by applying the transformations within the render loop. We are going to rotate and translate the rectangle so that it appears to be rotating about its centre.</p>
<p>If we calculate the transformation matrices inside the render loop we can move the rectangle around the window. A useful function to help us is <code class="docutils literal notranslate"><span class="pre">glfwGetTime()</span></code> from the GLFW library which returns the time in seconds since the GLFW window was created. If we have a time value that is always increasing we can use this to animate our rectangle.</p>
<p>Comment out all of the code used to calculate the transformation matrices we have entered so far this lab but leave the line where we get the location of the transformation uniform.</p>
<p>Inside the <strong>render loop</strong> just before we send the <code class="docutils literal notranslate"><span class="pre">transformation</span></code> matrix to the shader add the following code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate transformations</span>
<span class="kt">float</span><span class="w"> </span><span class="n">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glfwGetTime</span><span class="p">();</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.3f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">));</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">));</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">));</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">transformation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
</pre></div>
</div>
<p>Here we have defined the <code class="docutils literal notranslate"><span class="pre">translate</span></code>, <code class="docutils literal notranslate"><span class="pre">scale</span></code> and <code class="docutils literal notranslate"><span class="pre">rotate</span></code> matrices and used them to calculate the composite transformation matrix. Note that we have used the <code class="docutils literal notranslate"><span class="pre">time</span></code> variable which will cause the rectangle to rotate. Compile and run the program and you should see something similar to the following.</p>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/05_rotating_smiley_1.mp4" type="video/mp4">
</video>
</center>
<p>When calculating the composite transformation matrix the order in which we multiply the individual transformations will determine the effects of the composite transformation. To see the effect of this lets translate the rectangle first before rotating it by changing the <code class="docutils literal notranslate"><span class="pre">transformation</span></code> calculation to the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">transformation</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
</pre></div>
</div>
<p>Compile and run the program and we have something quite different.</p>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/05_rotating_smiley_2.mp4" type="video/mp4">
</video>
</center>
</section>
<hr class="docutils" />
<section id="exercises">
<h2><span class="section-number">5.6. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>Use translation to produce an animation of the original rectangle rotating around a circle of radius 0.5 centered at the centre of the window. Hint: the co-ordinates of points on a circle centered at (0,0) can be calculated using <span class="math notranslate nohighlight">\(x = {\tt radius} \cdot \cos({\tt time})\)</span> and <span class="math notranslate nohighlight">\(y = {\tt radius} \cdot \sin({\tt time})\)</span> where <span class="math notranslate nohighlight">\(t\)</span> is some number.</p></li>
</ol>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/05_Ex1.mp4" type="video/mp4">
</video>
</center>
<ol class="arabic simple" start="2">
<li><p>Use rotation to rotate the rectangle from exercise 1 clockwise about its own centre with a rotation speed double that of the rotation speed used to rotate it around the circle.</p></li>
</ol>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/05_Ex2.mp4" type="video/mp4">
</video>
</center>
<ol class="arabic simple">
<li><p>Use scaling to scale the rectangle so that it grows and shrinks as it is moving. Hint: the function <span class="math notranslate nohighlight">\(s = 1 + 0.5 \sin(a \cdot {\tt time})\)</span> oscillates between 0.5 and 1.5 as time increases. Experiment with the speed of which the rectangle grows and shrinks by changing the value of <span class="math notranslate nohighlight">\(a\)</span>.</p></li>
</ol>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/05_Ex3.mp4" type="video/mp4">
</video>
</center>
<ol class="arabic simple" start="4">
<li><p>Create your own class called <code class="docutils literal notranslate"><span class="pre">MyLib</span></code> using header and code files <code class="docutils literal notranslate"><span class="pre">MyLib.hpp</span></code> and <code class="docutils literal notranslate"><span class="pre">MyLib.cpp</span></code> that includes static member functions to calculate the translation, scaling and angle-axis rotation matrices (you may use <code class="docutils literal notranslate"><span class="pre">glm::mat4()</span></code>, <code class="docutils literal notranslate"><span class="pre">glm::vec3()</span></code> and the <code class="docutils literal notranslate"><span class="pre">cmath</span></code> library). Replace the glm functions <code class="docutils literal notranslate"><span class="pre">glm::translate()</span></code>, <code class="docutils literal notranslate"><span class="pre">glm::scale()</span></code> and <code class="docutils literal notranslate"><span class="pre">glm::rotate()</span></code> with functions from MyLib to answer exercises 1 to 3.</p></li>
</ol>
</section>
<hr class="docutils" />
<section id="source-code">
<h2><span class="section-number">5.7. </span>Source code<a class="headerlink" href="#source-code" title="Permalink to this heading">#</a></h2>
<p>The source code for this lab, including the exercise solutions, can be downloaded using the links below.</p>
<ul class="simple">
<li><p><a class="reference download internal" download="" href="../_downloads/8afd0cac2c06efaa49caba49bf365a2b/Lab05_solutions.cpp"><span class="xref download myst">main.cpp</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/2117703f903726f74c48895b251be18d/MyLib.hpp"><span class="xref download myst">MyLib.hpp</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/498c05a6427207225443f634dd2d9a3d/MyLib.cpp"><span class="xref download myst">MyLib.cpp</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/190b17b6b486c301279d23e0c2b1f2ca/vertexShader.vert"><span class="xref download myst">vertexShader.vert</span></a></p></li>
</ul>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./pages"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="04_vectors_and_matrices.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">4. </span>Vectors and Matrices</p>
      </div>
    </a>
    <a class="right-next"
       href="06_3D_worlds.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">6. </span>3D Worlds</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#translation">5.1. Translation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#translation-in-opengl">5.1.1. Translation in OpenGL</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#scaling">5.2. Scaling</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#scaling-in-opengl">5.2.1. Scaling in OpenGL</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#rotation">5.3. Rotation</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#rotation-in-opengl">5.3.1. Rotation in OpenGL</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#axis-angle-rotation">5.3.2. Axis-angle rotation</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#composite-transformations">5.4. Composite transformations</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#composite-transformations-in-opengl">5.4.1. Composite transformations in OpenGL</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#animating-objects">5.5. Animating objects</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">5.6. Exercises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#source-code">5.7. Source code</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Dr Jon Shiach
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>