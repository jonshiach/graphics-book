

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>6. 3D Worlds &#8212; Computer Graphics Labs</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"tex": {"macros": {"vec": ["\\mathbf{#1}", 1]}}, "options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'pages/06_3D_worlds';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="7. Moving the camera" href="07_Moving_the_camera.html" />
    <link rel="prev" title="5. Transformations" href="05_transformations.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo.svg" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../_static/logo.svg" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Computer Graphics
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="01_intro_to_cpp.html">1. Introduction to C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="02_basic_shapes_in_OpenGL.html">2. Basic Shapes in OpenGL</a></li>
<li class="toctree-l1"><a class="reference internal" href="03_textures.html">3. Textures</a></li>
<li class="toctree-l1"><a class="reference internal" href="04_vectors_and_matrices.html">4. Vectors and Matrices</a></li>
<li class="toctree-l1"><a class="reference internal" href="05_transformations.html">5. Transformations</a></li>
<li class="toctree-l1 current active"><a class="current reference internal" href="#">6. 3D Worlds</a></li>
<li class="toctree-l1"><a class="reference internal" href="07_Moving_the_camera.html">7. Moving the camera</a></li>
<li class="toctree-l1"><a class="reference internal" href="08_Lighting.html">8. Lighting</a></li>
<li class="toctree-l1"><a class="reference internal" href="09_Normal_mapping.html">9. Normal Mapping</a></li>
<li class="toctree-l1"><a class="reference internal" href="10_Quaternions.html">10. Quaternions</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Appendices</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="A_Complex_numbers_and_quaternions.html">A. Complex Numbers and Quaternions</a></li>
<li class="toctree-l1"><a class="reference internal" href="B_Code.html">B. Code and Assets</a></li>
<li class="toctree-l1"><a class="reference internal" href="C_Glossary.html">C Glossary</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/jonshiach/graphics-labs/issues/new?title=Issue%20on%20page%20%2Fpages/06_3D_worlds.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/pages/06_3D_worlds.md" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.md</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>3D Worlds</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#d-models">6.1. 3D models</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#co-ordinate-systems">6.2. Co-ordinate systems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#model-view-and-projection-matrices">6.3. Model, view and projection matrices</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-model-matrix">6.3.1. The model matrix</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-view-matrix">6.3.2. The view matrix</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#projection">6.3.3. Projection</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#applying-the-model-view-and-projection-matrices">6.3.4. Applying the model, view and projection matrices</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-z-buffer">6.4. The z buffer</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#perspective-projection">6.5. Perspective projection</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#changing-the-fov-angle">6.5.1. Changing the fov angle</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#glm-transformations">6.6. glm transformations</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multiple-objects">6.7. Multiple objects</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-camera-class">6.8. A camera class</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">6.9. Exercises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#source-code">6.10. Source code</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#video-walkthrough">6.11. Video walkthrough</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="d-worlds">
<span id="d-worlds-section"></span><h1><span class="section-number">6. </span>3D Worlds<a class="headerlink" href="#d-worlds" title="Permalink to this heading">#</a></h1>
<p>In <a class="reference internal" href="05_transformations.html#transformations-section"><span class="std std-ref">Lab 5</span></a> we looked at the transformations can can be applied to the vertex co-ordinates <span class="math notranslate nohighlight">\((x, y, z, 1)\)</span> but all of our examples were using 2D objects. In this lab we will take the step into the third spatial dimension and look at 3D worlds.</p>
<p>First download and build the project files for this lab.</p>
<ol class="arabic simple">
<li><p>Go to <a href="https://github.com/jonshiach/Lab06_3D_worlds" target="_blank">https://github.com/jonshiach/Lab06_3D_worlds</a> and follow the instructions to download and build the project files.</p></li>
<li><p>Open the project file <code class="docutils literal notranslate"><span class="pre">Lab06_3D_worlds.sln</span></code> (or <code class="docutils literal notranslate"><span class="pre">Lab06_3D_worlds.xcodeproj</span></code> on macOS) set the <strong>Lab06_3D_worlds</strong> project as the startup project.</p>
<ul class="simple">
<li><p>Visual Studio: right-click on the <strong>Lab06_3D_worlds</strong> project and select <strong>Set as Startup Project</strong>.</p></li>
<li><p>Xcode: Click on the target select dropdown (to the right of the name of the project at the top of the window) and select <strong>Lab06_3D_worlds</strong> as the target.</p></li>
</ul>
</li>
<li><p>Build the project by pressing CTRL + B (or ⌘B on Xcode) which should build the project without errors. Run the executable by pressing F5 (or ⌘R on Xcode).</p></li>
</ol>
<section id="d-models">
<h2><span class="section-number">6.1. </span>3D models<a class="headerlink" href="#d-models" title="Permalink to this heading">#</a></h2>
<p>To demonstrate building a simple 3D world we are going to need a 3D object. One of the simplest 3D objects is a <strong>unit cube</strong> which is a cube centred at (0,0,0) and has side lengths of 2 parallel to the co-ordinate axes (<a class="reference internal" href="#unit-cube-figure"><span class="std std-numref">Fig. 6.1</span></a>) so the co-ordinates of the 8 corners of the cube are combinations of -1 and 1.</p>
<figure class="align-default" id="unit-cube-figure">
<a class="reference internal image-reference" href="../_images/06_Unit_cube.svg"><img alt="../_images/06_Unit_cube.svg" src="../_images/06_Unit_cube.svg" width="700" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6.1 </span><span class="caption-text">A unit cube.</span><a class="headerlink" href="#unit-cube-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>Open up the project and take a look at the <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> file and you will see that the arrays <code class="docutils literal notranslate"><span class="pre">vertices</span></code> and <code class="docutils literal notranslate"><span class="pre">uvCoords</span></code> arrays have been defined for our unit cube.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Define vertex co-ordinates</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">GLfloat</span><span class="w"> </span><span class="n">vertices</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// front</span>
<span class="w">   </span><span class="mf">-1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">    </span><span class="c1">//              + ------ +</span>
<span class="w">    </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">    </span><span class="c1">//             /|       /|</span>
<span class="w">    </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">    </span><span class="c1">//   y        / |      / |</span>
<span class="w">   </span><span class="mf">-1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">    </span><span class="c1">//   |       + ------ +  |</span>
<span class="w">    </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">    </span><span class="c1">//   + - x   |  + ----|- +</span>
<span class="w">   </span><span class="mf">-1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">    </span><span class="c1">//  /        | /      | /</span>
<span class="w">   </span><span class="c1">// right                // z         |/       |/</span>
<span class="w">    </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">    </span><span class="c1">//           + ------ +</span>
<span class="w">    </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">,</span>
<span class="w">    </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">,</span>
<span class="w">    </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span>
<span class="w">    </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">,</span>
<span class="w">    </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span>
<span class="w">    </span><span class="c1">// etc.</span>
<span class="p">};</span>

<span class="c1">// Define texture vertices</span>
<span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">GLfloat</span><span class="w"> </span><span class="n">uvCoords</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">     </span><span class="c1">// vertex co-ordinates are the same for each side</span>
<span class="w">   </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">     </span><span class="c1">// of the cube so repeat every six vertices</span>
<span class="w">   </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span>
<span class="w">   </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span>
<span class="w">   </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span>
<span class="w">   </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span>
<span class="w">   </span><span class="c1">// etc.</span>
<span class="p">};</span>
</pre></div>
</div>
<p>If you compile and run this program you will see that the <code class="docutils literal notranslate"><span class="pre">crate.bmp</span></code> texture fills the window.</p>
</section>
<section id="co-ordinate-systems">
<h2><span class="section-number">6.2. </span>Co-ordinate systems<a class="headerlink" href="#co-ordinate-systems" title="Permalink to this heading">#</a></h2>
<p>OpenGL uses a co-ordinate system with the <span class="math notranslate nohighlight">\(x\)</span> axis pointing horizontally to the right, the <span class="math notranslate nohighlight">\(y\)</span> axis pointing vertically upwards and the <span class="math notranslate nohighlight">\(z\)</span> axis pointing horizontally towards the viewer. To simplify things when it comes to displaying the 3D world, the axes are limited to a range from -1 to 1 so any object outside of this range will not be shown on the display. These are known as <strong>Normalised Device Co-ordinates (NDC)</strong>.</p>
<figure class="align-default" id="ndc-figure">
<a class="reference internal image-reference" href="../_images/06_NDC.svg"><img alt="../_images/06_NDC.svg" src="../_images/06_NDC.svg" width="500" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6.2 </span><span class="caption-text">Normalise Device Co-ordinates (NDC)</span><a class="headerlink" href="#ndc-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The steps used in the creation of a 3D world and eventually displaying it on screen requires that we transform through several intermediate co-ordinate systems:</p>
<ul class="simple">
<li><p><strong>Model space</strong> - each individual 3D object that will appear in the 3D world is defined in its own space usually with the centre of the object at (0,0,0) to make the transformations easier.</p></li>
<li><p><strong>World space</strong> - the 3D world is constructed by transforming the individual 3D objects using translation, rotation and scaling transformations. The co-ordinates of the objects is arbitrary and left to the choice of the designer of the 3D world.</p></li>
<li><p><strong>View space</strong> - the world space is transformed so that the position of the viewer, in other words the camera, is at (0,0,0) and the direction the camera is pointing is down the <span class="math notranslate nohighlight">\(z\)</span> axis, i.e., parallel to (0,0,-1).</p></li>
<li><p><strong>Screen space</strong> - the view space is transformed so that the co-ordinates are in NDC. The volume of the view space that is contained in the screen space is chosen by the user.</p></li>
</ul>
<figure class="align-default" id="id1">
<a class="reference internal image-reference" href="../_images/06_mvp.svg"><img alt="../_images/06_mvp.svg" src="../_images/06_mvp.svg" width="500" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6.3 </span><span class="caption-text">Transformations between different spaces.</span><a class="headerlink" href="#id1" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</section>
<section id="model-view-and-projection-matrices">
<h2><span class="section-number">6.3. </span>Model, view and projection matrices<a class="headerlink" href="#model-view-and-projection-matrices" title="Permalink to this heading">#</a></h2>
<p>We saw in <a class="reference internal" href="05_transformations.html#transformations-section"><span class="std std-ref">Lab 5</span></a> that we apply a transformation by multiplying the object co-ordinates by a transformation matrix. Since we are transforming between difference co-ordinate spaces we have 3 main transformation matrices</p>
<ul class="simple">
<li><p>the <strong>model</strong> matrix - combined scaling, rotation and translation applied to each individual object</p></li>
<li><p>the <strong>view</strong> matrix - combined translation and alignment transformations</p></li>
<li><p>the <strong>projection</strong> matrix - combined projection of the view space and scaling to NDC</p></li>
</ul>
<section id="the-model-matrix">
<span id="model-matrix-section"></span><h3><span class="section-number">6.3.1. </span>The model matrix<a class="headerlink" href="#the-model-matrix" title="Permalink to this heading">#</a></h3>
<p>In <a class="reference internal" href="05_transformations.html#transformations-section"><span class="std std-ref">Lab 5</span></a> we saw that we can combine transformations such as translation, scaling and rotation by multiplying the individual transformation matrices together. The <strong>model matrix</strong> is the matrix that is used to apply transformations to an object.</p>
<p>Lets compute a model matrix for our cube where it is scaled down by a factor of 0.5 in each co-ordinate direction, rotated about the <span class="math notranslate nohighlight">\(y\)</span> axis using the time of the current frame as the rotation angle and translated backwards down the <span class="math notranslate nohighlight">\(z\)</span>-axis so that its centre is at (0, 0, -4). Add the following code <strong>inside the rendering loop</strong> before we call the <code class="docutils literal notranslate"><span class="pre">glDrawArrays()</span></code> function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate the model matrix</span>
<span class="kt">float</span><span class="w"> </span><span class="n">time</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glfwGetTime</span><span class="p">();</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-4.0f</span><span class="p">));</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">));</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">));</span>

<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
</pre></div>
</div>
<p>Here we have calculated the individual transformation matrices for translation, scaling and rotation and multiply them to give the <code class="docutils literal notranslate"><span class="pre">model</span></code> matrix.</p>
</section>
<section id="the-view-matrix">
<span id="view-matrix-section"></span><h3><span class="section-number">6.3.2. </span>The view matrix<a class="headerlink" href="#the-view-matrix" title="Permalink to this heading">#</a></h3>
<p>OpenGL assumes that the camera is always at (0,0,0) and looking down the <span class="math notranslate nohighlight">\(z\)</span>-axis so we need to transform the co-ordinates to this <strong>view space</strong> (<a class="reference internal" href="#view-space-figure"><span class="std std-numref">Fig. 6.4</span></a>).</p>
<figure class="align-default" id="view-space-figure">
<a class="reference internal image-reference" href="../_images/06_view_space.svg"><img alt="../_images/06_view_space.svg" src="../_images/06_view_space.svg" width="350" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6.4 </span><span class="caption-text">The view space.</span><a class="headerlink" href="#view-space-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>To calculate the world space to view space transformation we require three vectors</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\tt position\)</span> - the co-ordinates of the camera position</p></li>
<li><p><span class="math notranslate nohighlight">\(\tt target\)</span> - the co-ordinates of the target point that the camera is looking towards</p></li>
<li><p><span class="math notranslate nohighlight">\(\tt worldUp\)</span> - a vector pointing straight up in the world space which allows us to orientate the camera, this is usually always (0,1,0)</p></li>
</ul>
<figure class="align-default" id="view-space-alignment-figure">
<a class="reference internal image-reference" href="../_images/06_view_space_alignment.svg"><img alt="../_images/06_view_space_alignment.svg" src="../_images/06_view_space_alignment.svg" width="400" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6.5 </span><span class="caption-text">The vectors used in the transformation to the view space.</span><a class="headerlink" href="#view-space-alignment-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The <span class="math notranslate nohighlight">\(\tt position\)</span> and <span class="math notranslate nohighlight">\(\tt target\)</span> vectors are either determined by the user through keyboard, mouse or controller inputs or through some predetermined routine. To determine the view space transformation we first translate the camera position to (0,0,0) using the following translation matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \textsf{translation matrix} =
    \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 1 &amp; 0 \\
        -\tt position.x &amp; -\tt position.y &amp; -\tt position.z &amp; 1
    \end{pmatrix}
\end{align*}. \end{split}\]</div>
<p>The next step is to align the world space so that the direction vector is pointing down the <span class="math notranslate nohighlight">\(z\)</span> axis. To do this we use vectors <span class="math notranslate nohighlight">\(\tt right\)</span>, <span class="math notranslate nohighlight">\(\tt up\)</span> and <span class="math notranslate nohighlight">\(\tt front\)</span> which are unit vectors at right-angles to each other the point in directions relative to the camera (<a class="reference internal" href="#view-space-alignment-figure"><span class="std std-numref">Fig. 6.5</span></a>).</p>
<p>The <span class="math notranslate nohighlight">\(\tt front\)</span> vector points directly forward of the camera and is calculated using</p>
<div class="math notranslate nohighlight">
\[ \texttt{front} = \textsf{normalise}(\tt target - position).\]</div>
<p>The <span class="math notranslate nohighlight">\(\tt right\)</span> vector points to the right of the camera so is at right-angles to both the <span class="math notranslate nohighlight">\(\tt front\)</span> and <span class="math notranslate nohighlight">\(\tt worldUp\)</span> vectors. We can use the <a class="reference internal" href="04_vectors_and_matrices.html#cross-product-section"><span class="std std-ref">cross product</span></a> between the two vectors to calculate this (note that the order of the vectors is important).</p>
<div class="math notranslate nohighlight">
\[ \tt right = \textsf{normalise}(front \times worldUp) .\]</div>
<p>The <span class="math notranslate nohighlight">\(\tt up\)</span> vector points in the up direction of the camera and is at right-angles to the <span class="math notranslate nohighlight">\(\tt front\)</span> and <span class="math notranslate nohighlight">\(\tt right\)</span> vectors we have already calculated. So this can be calculated using another cross product.</p>
<div class="math notranslate nohighlight">
\[ \tt up = \textsf{normalise}(right \times front).\]</div>
<p>Once these vectors have been calculated the transformation matrix to align the <span class="math notranslate nohighlight">\(\tt front\)</span> vector so that it points down the <span class="math notranslate nohighlight">\(z\)</span>-axis is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\textsf{alignment matrix} = \begin{pmatrix}
    \tt right.x &amp; \tt up.x &amp; \tt -front.x &amp; 0 \\
    \tt right.y &amp; \tt up.y &amp; \tt -front.y &amp; 0 \\
    \tt right.z &amp; \tt up.z &amp; \tt -front.z &amp; 0 \\
    0 &amp; 0 &amp; 0 &amp; 1
\end{pmatrix}.\end{split}\]</div>
<p>The translation matrix and alignment matrix are multiplied together to form the <strong>view matrix</strong> which transforms the world space co-ordinates to the view space.</p>
<div class="math notranslate nohighlight">
\[ \begin{align*}
    \textsf{view matrix} &amp;= \textsf{translation matrix} \cdot \textsf{alignment matrix}.
\end{align*} \]</div>
<p>Lets move the camera to look at our cube from the position (1,1,0) looking towards the center of the cube. Add the following to the <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> file after we have calculated the <code class="docutils literal notranslate"><span class="pre">model</span></code> matrix.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate view matrix</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-4.0f</span><span class="p">);</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">worldUp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>

<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">front</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">target</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">position</span><span class="p">);</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">cross</span><span class="p">(</span><span class="n">front</span><span class="p">,</span><span class="w"> </span><span class="n">worldUp</span><span class="p">));</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">cross</span><span class="p">(</span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">front</span><span class="p">));</span>

<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">align</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>

<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">translate</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">position</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="n">align</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">right</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="n">align</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">up</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">    </span><span class="n">align</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">front</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>

<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">align</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">translate</span><span class="p">;</span>
</pre></div>
</div>
</section>
<section id="projection">
<h3><span class="section-number">6.3.3. </span>Projection<a class="headerlink" href="#projection" title="Permalink to this heading">#</a></h3>
<p>The next step is to project the view space onto the screen space. OpenGL uses NDC where the screen space is a unit cube where axes co-ordinates range from -1 to 1. Any fragments with co-ordinates outside of this range are <strong>clipped</strong> and ignored by the shaders. The simplest type of projection is <strong>orthographic projection</strong> where the co-ordinates in the view space are transformed to the screen space by simple translation and scaling transformations.</p>
<p>The region of the view space that will form the screen space is defined by a cuboid bounded by a left, right, bottom, top, near and far clipping planes. Any objects outside of the cuboid are clipped and discarded from the rendering (<a class="reference internal" href="#orthographic-projection-figure"><span class="std std-numref">Fig. 6.6</span></a>).</p>
<figure class="align-default" id="orthographic-projection-figure">
<a class="reference internal image-reference" href="../_images/06_orthographic_projection.svg"><img alt="../_images/06_orthographic_projection.svg" src="../_images/06_orthographic_projection.svg" width="600" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6.6 </span><span class="caption-text">Orthographic projection.</span><a class="headerlink" href="#orthographic-projection-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The <strong>orthographic projection matrix</strong> is calculated using the left, right, bottom, top, near and far co-ordinates such that</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \textsf{orthographic projection matrix} = 
    \begin{pmatrix}
        \frac{2}{\textsf{right} - \textsf{left}} &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; \frac{2}{\textsf{top} - \textsf{bottom}} &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; \frac{2}{\textsf{near} - \textsf{far}} &amp; 0 \\
        -\frac{\textsf{right} + \textsf{left}}{\textsf{right} - \textsf{left}} &amp; -\frac{\textsf{top} + \textsf{bottom}}{\textsf{top} - \textsf{bottom}} &amp; \frac{\textsf{near} + \textsf{far}}{\textsf{near} - \textsf{far}} &amp; 1
    \end{pmatrix}
\end{align*}. \end{split}\]</div>
<p>You don’t really need to know how this matrix is derived but if you are interested click on the dropdown link below.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Derivation of the orthographic projection matrix<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text">To derive the orthographic projection we first need to translate the co-ordinates so that the centre of the cuboid that represents the clipping volume to (0,0,0). The centre co-ordinates are calculated using the average of the edge co-ordinates, e.g., for the <span class="math notranslate nohighlight">\(x\)</span> co-ordinate this would be <span class="math notranslate nohighlight">\(\frac{\textsf{right} + \textsf{left}}{2}\)</span>, so the translation matrix is</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \textsf{translation matrix} = 
    \begin{pmatrix}
        1 &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; 1 &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; 1 &amp; 0 \\
        -\frac{\textsf{right} + \textsf{left}}{2} &amp; -\frac{\textsf{top} + \textsf{bottom}}{2} &amp; \frac{\textsf{near} + \textsf{far}}{2} &amp; 1
    \end{pmatrix}
\end{align*} \end{split}\]</div>
<p class="sd-card-text">The second step is to scale the clipping volume so that the co-ordinates are between -1 and 1. This is done by dividing the distance between the edges of the screen space by the distance between the clipping planes, e.g., for the <span class="math notranslate nohighlight">\(x\)</span> co-ordinate this would be <span class="math notranslate nohighlight">\(\frac{1 - (-1)}{\textsf{right} - \textsf{left}}=\frac{2}{\textsf{right} - \textsf{left}}\)</span>, so the scaling matrix is</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \textsf{scaling matrix} = 
    \begin{pmatrix}
        \frac{2}{\textsf{right} - \textsf{left}} &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; \frac{2}{\textsf{top} - \textsf{bottom}} &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; \frac{2}{\textsf{near} - \textsf{far}} &amp; 0 \\
        0 &amp; 0 &amp; 0 &amp; 1
    \end{pmatrix}.
\end{align*} \end{split}\]</div>
<p class="sd-card-text">Combining the translation and scaling matrices gives the orthographic projection matrix</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \textsf{orthographic projection matrix} &amp;=  \textsf{translation matrix} \cdot \textsf{scaling matrix}\\
    &amp;=
    \begin{pmatrix}
        \frac{2}{\textsf{right} - \textsf{left}} &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; \frac{2}{\textsf{top} - \textsf{bottom}} &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; \frac{2}{\textsf{near} - \textsf{far}} &amp; 0 \\
        -\frac{\textsf{right} + \textsf{left}}{\textsf{right} - \textsf{left}} &amp; -\frac{\textsf{top} + \textsf{bottom}}{\textsf{top} - \textsf{bottom}} &amp; \frac{\textsf{near} + \textsf{far}}{\textsf{near} - \textsf{far}} &amp; 1
    \end{pmatrix}
\end{align*} \end{split}\]</div>
</div>
</details><p>Lets calculate the orthographic projection matrix using left = -2, right = 2, bottom = -2, top = 2, near = 0, far = 10. Add the following code after we have calculated the <code class="docutils literal notranslate"><span class="pre">view</span></code> matrix.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate projection matrix (orthographic projection)</span>
<span class="kt">float</span><span class="w"> </span><span class="n">left</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">near</span><span class="p">,</span><span class="w"> </span><span class="n">far</span><span class="p">,</span><span class="w"> </span><span class="n">top</span><span class="p">,</span><span class="w"> </span><span class="n">bottom</span><span class="p">;</span>
<span class="n">left</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-2.0f</span><span class="p">,</span><span class="w"> </span><span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">;</span>
<span class="n">bottom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-2.0f</span><span class="p">,</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">;</span>
<span class="n">near</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="n">far</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">10.0f</span><span class="p">;</span>

<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">projection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
<span class="n">projection</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">left</span><span class="p">);</span>
<span class="n">projection</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">bottom</span><span class="p">);</span>
<span class="n">projection</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">near</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">far</span><span class="p">);</span>
<span class="n">projection</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">left</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">right</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">left</span><span class="p">);</span>
<span class="n">projection</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">bottom</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">bottom</span><span class="p">);</span>
<span class="n">projection</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">near</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">far</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">near</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">far</span><span class="p">);</span>
</pre></div>
</div>
</section>
<section id="applying-the-model-view-and-projection-matrices">
<h3><span class="section-number">6.3.4. </span>Applying the model, view and projection matrices<a class="headerlink" href="#applying-the-model-view-and-projection-matrices" title="Permalink to this heading">#</a></h3>
<p>Now that we have defined the <code class="docutils literal notranslate"><span class="pre">model</span></code>, <code class="docutils literal notranslate"><span class="pre">view</span></code> and <code class="docutils literal notranslate"><span class="pre">projection</span></code> matrices we need send it to the shader and apply the transformations. First we need to get the handle of the uniforms for each of the matrices, we do this in the same way as we did for the textures in <a class="reference internal" href="03_textures.html#textures-section"><span class="std std-ref">Lab 3</span></a>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Get the handles for the shader uniforms</span>
<span class="n">GLuint</span><span class="w"> </span><span class="n">texture1ID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;texture1Sampler&quot;</span><span class="p">);</span>
<span class="n">GLuint</span><span class="w"> </span><span class="n">modelID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;model&quot;</span><span class="p">);</span>
<span class="n">GLuint</span><span class="w"> </span><span class="n">viewID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;view&quot;</span><span class="p">);</span>
<span class="n">GLuint</span><span class="w"> </span><span class="n">projectionID</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glGetUniformLocation</span><span class="p">(</span><span class="n">shaderID</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;projection&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>We can now send the matrices to the vertex shader, add the following code after we have calculated the <code class="docutils literal notranslate"><span class="pre">model</span></code>, <code class="docutils literal notranslate"><span class="pre">view</span></code> and <code class="docutils literal notranslate"><span class="pre">projection</span></code> matrices.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Send the model view and projection matrices to the shader</span>
<span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">modelID</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">viewID</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">view</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">projectionID</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">projection</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
</pre></div>
</div>
<p>Of course we also need to update the vertex shader so that is uses the <code class="docutils literal notranslate"><span class="pre">model</span></code>, <code class="docutils literal notranslate"><span class="pre">view</span></code> and <code class="docutils literal notranslate"><span class="pre">projection</span></code> matrices. Edit <code class="docutils literal notranslate"><span class="pre">vertexShader.vert</span></code> so that the <code class="docutils literal notranslate"><span class="pre">gl_Position</span></code> vector is calculated as follows.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#version 330 core</span>

<span class="c1">// Input vertex data</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="n">layout</span><span class="p">(</span><span class="n">location</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">textureCoords</span><span class="p">;</span>

<span class="c1">// Output data</span>
<span class="n">out</span><span class="w"> </span><span class="n">vec2</span><span class="w"> </span><span class="n">uv</span><span class="p">;</span>

<span class="c1">// Uniforms</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">mat4</span><span class="w"> </span><span class="n">model</span><span class="p">;</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">mat4</span><span class="w"> </span><span class="n">view</span><span class="p">;</span>
<span class="n">uniform</span><span class="w"> </span><span class="n">mat4</span><span class="w"> </span><span class="n">projection</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Output vertex postion</span>
<span class="w">    </span><span class="n">gl_Position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">projection</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">vec4</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Output (u,v) co-ordinates</span>
<span class="w">    </span><span class="n">uv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vec2</span><span class="p">(</span><span class="n">textureCoords</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Compile and run the program and you should see the following.</p>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/06_orthogonal_cube_no_depth_test.mp4" type="video/mp4">
</video>
</center>
<p>If you are having difficulty getting to this stage take a look at the source code <a class="reference download internal" download="" href="../_downloads/4b151e57796938464491b1a3d82d5c7f/main_no_depth_test.cpp"><span class="xref download myst">main.cpp</span></a> and vertex shader <a class="reference download internal" download="" href="../_downloads/9d7da34a49ec481d18e120d9b539f349/vertexShader.vert"><span class="xref download myst">vertexShader.vert</span></a>.</p>
</section>
</section>
<section id="the-z-buffer">
<h2><span class="section-number">6.4. </span>The z buffer<a class="headerlink" href="#the-z-buffer" title="Permalink to this heading">#</a></h2>
<p>Our rendering of the cube doesn’t look quite right. What is happening here is that some parts of the sides of the cube that are further away from where we are viewing it (e.g., the bottom side) have been rendered after the sides that are closer to us (<a class="reference internal" href="#depth-test-1-figure"><span class="std std-numref">Fig. 6.7</span></a>).</p>
<figure class="align-default" id="depth-test-1-figure">
<a class="reference internal image-reference" href="../_images/06_depth_test.svg"><img alt="../_images/06_depth_test.svg" src="../_images/06_depth_test.svg" width="300" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6.7 </span><span class="caption-text">Rendering the far triangle after the near triangle.</span><a class="headerlink" href="#depth-test-1-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>To overcome this issue OpenGL uses a <strong>depth test</strong> when computing the fragment shader. When OpenGL creates a frame buffer it also creates another buffer called a <strong>z buffer</strong> (or <strong>depth buffer</strong>) where the <span class="math notranslate nohighlight">\(z\)</span> co-ordinate of each pixel in the frame buffer is stored and initialises all the values to -1 (the furthest possible <span class="math notranslate nohighlight">\(z\)</span> co-ordinate in the screen space). When the fragment shader is called it checks whether the fragment has a <span class="math notranslate nohighlight">\(z\)</span> co-ordinate more than that already stored in the depth buffer and if so it updates the colour of the fragment and stores its <span class="math notranslate nohighlight">\(z\)</span> co-ordinate in the depth-buffer as the current nearest fragment (if the fragment has a <span class="math notranslate nohighlight">\(z\)</span> co-ordinate less than what is already in the depth buffer the fragment shader does nothing). This means once the fragment shader has been called for all fragments of all objects, the pixels contain colours of the objects closest to the camera.</p>
<p>To enable depth testing we used the following function before the rendering loop.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Enable depth test</span>
<span class="n">glEnable</span><span class="p">(</span><span class="n">GL_DEPTH_TEST</span><span class="p">);</span>
</pre></div>
</div>
<p>We also need to clear the depth buffer at the start of each frame, change <code class="docutils literal notranslate"><span class="pre">glClear(GL_COLOR_BUFFER_BIT);</span></code> to the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Clear the window</span>
<span class="n">glClear</span><span class="p">(</span><span class="n">GL_COLOR_BUFFER_BIT</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">GL_DEPTH_BUFFER_BIT</span><span class="p">);</span>
</pre></div>
</div>
<p>Make these changes to your code and you should get a much better result.</p>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/06_orthogonal_cube.mp4" type="video/mp4">
</video>
</center>
</section>
<section id="perspective-projection">
<h2><span class="section-number">6.5. </span>Perspective projection<a class="headerlink" href="#perspective-projection" title="Permalink to this heading">#</a></h2>
<p>The problem with using orthographic projection is that is does not give us any clues to how far an object is from the viewer. We would expect that objects further away from the camera would appear smaller whereas objects closer to the camera would appear larger.</p>
<p>Perspective project uses the same near and far clipping planes as orthographic projection but the clipping planes on the sides are not parallel, rather they angle in such that the four planes meet at (0,0,0) (<a class="reference internal" href="#perspective-projection-figure"><span class="std std-numref">Fig. 6.8</span></a>). The clipping volume bounded by the size clipping planes is called the <strong>viewing frustum</strong>.</p>
<figure class="align-default" id="perspective-projection-figure">
<a class="reference internal image-reference" href="../_images/06_perspective_projection.svg"><img alt="../_images/06_perspective_projection.svg" src="../_images/06_perspective_projection.svg" width="600" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6.8 </span><span class="caption-text">Perspective projection.</span><a class="headerlink" href="#perspective-projection-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The shape of the viewing frustum is determined by four factors:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\textsf{near}\)</span> – the distance from (0,0,0) to the near clipping plane</p></li>
<li><p><span class="math notranslate nohighlight">\(\textsf{far}\)</span> – the distance from (0,0,0) to the far clipping plane</p></li>
<li><p><span class="math notranslate nohighlight">\(\textsf{fov}\)</span> – the <strong>field of view</strong> angle between the bottom and top clipping planes (used to determine how much of the view space is visible)</p></li>
<li><p><span class="math notranslate nohighlight">\(\textsf{aspect}\)</span> – the width-to-height <strong>aspect ratio</strong> of the window</p></li>
</ul>
<p>Given these four factors we can calculate the <strong>perspective projection matrix</strong> using</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \textsf{perspective projection matrix} = 
    \begin{pmatrix}
        \frac{\textsf{near}}{\textsf{right}} &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; \frac{\textsf{near}}{\textsf{top}} &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; -\frac{\textsf{far} + \textsf{near}}{\textsf{far} - \textsf{near}} &amp; -1 \\
        0 &amp; 0 &amp; - \frac{2 \cdot \textsf{far} \cdot \textsf{near}}{\textsf{far} - \textsf{near}} &amp; 0
    \end{pmatrix},
\end{align*} \end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\textsf{top} = \textsf{near} \cdot \tan(\frac{\textsf{fov}}{2}\)</span>) and <span class="math notranslate nohighlight">\(\textsf{right} = \textsf{aspect} \cdot \textsf{top}\)</span>. You don’t really need to know how this is derived but it you are interested click on the dropdown below.</p>
<details class="sd-sphinx-override sd-dropdown sd-card sd-mb-3">
<summary class="sd-summary-title sd-card-header">
Derivation of the perspective projection matrix<div class="sd-summary-down docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-down" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M5.22 8.72a.75.75 0 000 1.06l6.25 6.25a.75.75 0 001.06 0l6.25-6.25a.75.75 0 00-1.06-1.06L12 14.44 6.28 8.72a.75.75 0 00-1.06 0z"></path></svg></div>
<div class="sd-summary-up docutils">
<svg version="1.1" width="1.5em" height="1.5em" class="sd-octicon sd-octicon-chevron-up" viewBox="0 0 24 24" aria-hidden="true"><path fill-rule="evenodd" d="M18.78 15.28a.75.75 0 000-1.06l-6.25-6.25a.75.75 0 00-1.06 0l-6.25 6.25a.75.75 0 101.06 1.06L12 9.56l5.72 5.72a.75.75 0 001.06 0z"></path></svg></div>
</summary><div class="sd-summary-content sd-card-body docutils">
<p class="sd-card-text">The mapping of a point in the view space with co-ordinates <span class="math notranslate nohighlight">\((x, y, z)\)</span> onto the near clipping plane to the point <span class="math notranslate nohighlight">\((x', y', -\textsf{near})\)</span> is shown in <a class="reference internal" href="#perspective-mapping-figure"><span class="std std-numref">Fig. 6.9</span></a>.</p>
<figure class="align-default" id="perspective-mapping-figure">
<a class="reference internal image-reference" href="../_images/06_perspective_projection_mapping.svg"><img alt="../_images/06_perspective_projection_mapping.svg" src="../_images/06_perspective_projection_mapping.svg" width="500" /></a>
<figcaption>
<p><span class="caption-number">Fig. 6.9 </span><span class="caption-text">Mapping of the point at <span class="math notranslate nohighlight">\((x,y,z)\)</span> onto the near plane using perspective.</span><a class="headerlink" href="#perspective-mapping-figure" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p class="sd-card-text">The ratio of <span class="math notranslate nohighlight">\(x\)</span> to <span class="math notranslate nohighlight">\(-z\)</span> distance is the same as the ratio of <span class="math notranslate nohighlight">\(x'\)</span> to <span class="math notranslate nohighlight">\(\textsf{near}\)</span> distance (and similar for <span class="math notranslate nohighlight">\(y'\)</span>) so</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \frac{x}{-z} &amp;= \frac{x'}{\textsf{near}} &amp;\implies
    x' &amp;= -\frac{x \cdot \textsf{near}}{z}, \\
    \frac{y}{-z} &amp;= \frac{y'}{\textsf{near}} &amp;\implies
    y' &amp;= -\frac{y \cdot \textsf{near}}{z},
\end{align*} \end{split}\]</div>
<p class="sd-card-text">So we are mapping <span class="math notranslate nohighlight">\((x, y)\)</span> to <span class="math notranslate nohighlight">\(\left( -\frac{x \cdot \textsf{near}}{z}, -\frac{y \cdot \textsf{near}}{z} \right)\)</span>. As well as the perspective mapping we also need to ensure that the mapped co-ordinates <span class="math notranslate nohighlight">\((x', y', z')\)</span> are between -1 and 1. Consider the mapping of the <span class="math notranslate nohighlight">\(x\)</span> co-ordinate</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \textsf{left} &amp;\leq x' \leq \textsf{right} \\
    -\textsf{right} &amp;\leq x' \leq \textsf{right}  &amp;&amp; \textsf{(since left $= -$ right)} \\
    -1 &amp;\leq \frac{x'}{\textsf{right}} \leq 1 &amp;&amp; \textsf{(divide by right)}
\end{align*} \end{split}\]</div>
<p class="sd-card-text">Since <span class="math notranslate nohighlight">\(x' = -\frac{x \cdot \textsf{near}}{z}\)</span> then</p>
<div class="math notranslate nohighlight">
\[ \begin{align*}
    -1 &amp;\leq -\frac{x \cdot \textsf{near}}{z \cdot \textsf{right}}\leq 1
\end{align*} \]</div>
<p class="sd-card-text">and doing similar for <span class="math notranslate nohighlight">\(y\)</span> we get</p>
<div class="math notranslate nohighlight">
\[ \begin{align*}
    -1 &amp;\leq -\frac{y \cdot \textsf{near}}{z \cdot \textsf{top}}\leq 1
\end{align*} \]</div>
<p class="sd-card-text">If we use <a class="reference internal" href="05_transformations.html#homogeneous-coordinates-section"><span class="std std-ref">homogeneous co-ordinates</span></a> then this mapping can be represented by the matrix equation</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    (x, y, z, 1)
    \begin{pmatrix}
        \frac{\textsf{near}}{\textsf{right}} &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; \frac{\textsf{near}}{\textsf{top}} &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; A &amp; -1 \\
        0 &amp; 0 &amp; B &amp; 0
    \end{pmatrix}
    =
    \left( \frac{x \cdot \textsf{near}}{\textsf{right}}, \frac{y \cdot \textsf{near}}{\textsf{top}}, Az + B, -z \right)
\end{align*} \end{split}\]</div>
<p class="sd-card-text">where <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> are placeholder variables for now. Since we divide homogeneous co-ordinates by the fourth element then</p>
<div class="math notranslate nohighlight">
\[ \left( -\frac{x \cdot \textsf{near}}{z \cdot \textsf{right}}, -\frac{y \cdot \textsf{near}}{z \cdot \textsf{top}}, \frac{Az + B}{-z}, 1 \right), \]</div>
<p class="sd-card-text">so the mapping for <span class="math notranslate nohighlight">\(x'\)</span> and <span class="math notranslate nohighlight">\(y'\)</span> is correct. We need <span class="math notranslate nohighlight">\(z'\)</span> to be between -1 and 1 so <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(B\)</span> must satisfy</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \textsf{near plane:} &amp;&amp;\frac{Az + B}{-z} &amp;= -1, &amp; \implies  Az + B &amp;= z, \\
    \textsf{far plane:} &amp;&amp; \frac{Az + B}{-z} &amp;= 1, &amp; \implies Az + B &amp;= -z.
\end{align*} \end{split}\]</div>
<p class="sd-card-text">At the near clipping plane <span class="math notranslate nohighlight">\(z = -\textsf{near}\)</span> and at the far clipping plane <span class="math notranslate nohighlight">\(z = -\textsf{far}\)</span> so</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    -A\cdot \textsf{near} + B &amp;= -\textsf{near}, \\
    -A\cdot \textsf{far} + B &amp;= \textsf{far}.
\end{align*} \end{split}\]</div>
<p class="sd-card-text">Subtracting the first equation from the second gives</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    -A (\textsf{far} - \textsf{near}) &amp;= \textsf{far} + \textsf{near} \\
    \therefore A &amp;= -\frac{\textsf{far} + \textsf{near}}{\textsf{far} - \textsf{near}}.
\end{align*} \end{split}\]</div>
<p class="sd-card-text">Substituting <span class="math notranslate nohighlight">\(A\)</span> in the second equation gives</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \frac{\textsf{far} + \textsf{near}}{\textsf{far} - \textsf{near}} \cdot \textsf{near} + B &amp;= -\textsf{near} \\
    B &amp;= -\textsf{near} \left( 1 +  \frac{\textsf{far} + \textsf{near}}{\textsf{far} - \textsf{near}}\right) \\
    &amp;= -\textsf{near} \left( \frac{\textsf{far} - \textsf{near} + \textsf{far} + \textsf{near}}{\textsf{far} - \textsf{near}}\right) \\
    &amp;= - \frac{2 \cdot \textsf{far} \cdot \textsf{near}}{\textsf{far} - \textsf{near}}.
\end{align*} \end{split}\]</div>
<p class="sd-card-text">So the perspective projection matrix is</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \textsf{perspective projection matrix} = 
    \begin{pmatrix}
        \frac{\textsf{near}}{\textsf{right}} &amp; 0 &amp; 0 &amp; 0 \\
        0 &amp; \frac{\textsf{near}}{\textsf{top}} &amp; 0 &amp; 0 \\
        0 &amp; 0 &amp; -\frac{\textsf{far} + \textsf{near}}{\textsf{far} - \textsf{near}} &amp; -1 \\
        0 &amp; 0 &amp; - \frac{2 \cdot \textsf{far} \cdot \textsf{near}}{\textsf{far} - \textsf{near}} &amp; 0
    \end{pmatrix},
\end{align*} \end{split}\]</div>
<p class="sd-card-text">We now need to calculate the values of <span class="math notranslate nohighlight">\(\textsf{right}\)</span> and <span class="math notranslate nohighlight">\(\textsf{top}\)</span>. The <span class="math notranslate nohighlight">\(\textsf{top}\)</span> co-ordinate is the opposite side of a right angled triangle with angle <span class="math notranslate nohighlight">\(\frac{\textsf{fov}}{2}\)</span> and adjacent side <span class="math notranslate nohighlight">\(\textsf{near}\)</span> so it is easily calculated using trigonometry</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \tan \left( \frac{\textsf{fov}}{2} \right) &amp;= \frac{\textsf{opposite}}{\textsf{adjacent}} = \frac{\textsf{top}}{\textsf{near}} \\
    \textsf{top} &amp;= \textsf{near} \cdot \tan \left( \frac{\textsf{fov}}{2} \right).
\end{align*} \end{split}\]</div>
<p class="sd-card-text">Since <span class="math notranslate nohighlight">\(\textsf{aspect}\)</span> with the width of the window divided by the height and <span class="math notranslate nohighlight">\(\textsf{left} = -\textsf{right}\)</span> and <span class="math notranslate nohighlight">\(\textsf{bottom} = -\textsf{top}\)</span> then</p>
<div class="math notranslate nohighlight">
\[\begin{split} \begin{align*}
    \textsf{aspect} &amp;= \frac{\textsf{right} - \textsf{left}}{\textsf{top} - \textsf{bottom}} = \frac{2 \cdot \textsf{right}}{2 \cdot \textsf{top}} \\
    \therefore \textsf{right} &amp;= \textsf{aspect} \cdot \textsf{top}.
\end{align*} \end{split}\]</div>
</div>
</details><p>Lets apply perspective projection to our cube using a near and far clipping planes at 0.2 and 10 respectively and a field of view angle of 45<span class="math notranslate nohighlight">\(^\circ\)</span>. Add the following code to your <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> file (you may want to comment out the code used to calculate the orthogonal projection matrix as we aren’t using it now).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate perspective projection matrix</span>
<span class="kt">float</span><span class="w"> </span><span class="n">right</span><span class="p">,</span><span class="w"> </span><span class="n">top</span><span class="p">,</span><span class="w"> </span><span class="n">near</span><span class="p">,</span><span class="w"> </span><span class="n">far</span><span class="p">,</span><span class="w"> </span><span class="n">fov</span><span class="p">,</span><span class="w"> </span><span class="n">aspect</span><span class="p">;</span>
<span class="n">fov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">45.0f</span><span class="p">);</span>
<span class="n">aspect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1024.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">768.0f</span><span class="p">;</span>
<span class="n">near</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.2f</span><span class="p">;</span>
<span class="n">far</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">100.0f</span><span class="p">;</span>
<span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">near</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">tan</span><span class="p">(</span><span class="n">fov</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="n">right</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aspect</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">top</span><span class="p">;</span>

<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">projection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">);</span>
<span class="n">projection</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">near</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">right</span><span class="p">;</span>
<span class="n">projection</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">near</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">top</span><span class="p">;</span>
<span class="n">projection</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">far</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">near</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">far</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">near</span><span class="p">);</span>
<span class="n">projection</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">;</span>
<span class="n">projection</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">far</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">near</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">far</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">near</span><span class="p">);;</span>
<span class="n">projection</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">;</span>
</pre></div>
</div>
<center>
<video controls muted="true" loop="true" width="500">
    <source src="../_static/06_perspective_cube.mp4" type="video/mp4">
</video>
</center>
<section id="changing-the-fov-angle">
<h3><span class="section-number">6.5.1. </span>Changing the fov angle<a class="headerlink" href="#changing-the-fov-angle" title="Permalink to this heading">#</a></h3>
<p>The field of view angle determines how much of the view space we can see in the screen space where the larger the angle the more we can see. When we increase the fov angle it appears to the user that our view is zooming out whereas when we decrease the fov it has the effect of zooming in (this is used a lot in first person shooter games to model the effect of a pair of binoculars or a sniper scope). This effect is shown on our cube object below.</p>
<div class="sd-container-fluid sd-sphinx-override sd-mb-4 docutils">
<div class="sd-row docutils">
<div class="sd-col sd-d-flex-column docutils">
<figure class="align-default" id="id2">
<img alt="../_images/06_fov_15.png" src="../_images/06_fov_15.png" />
<figcaption>
<p><span class="caption-number">Fig. 6.10 </span><span class="caption-text"><span class="math notranslate nohighlight">\(\textsf{fov} = 15^\circ\)</span></span><a class="headerlink" href="#id2" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
<div class="sd-col sd-d-flex-column docutils">
<figure class="align-default" id="id3">
<img alt="../_images/06_fov_90.png" src="../_images/06_fov_90.png" />
<figcaption>
<p><span class="caption-number">Fig. 6.11 </span><span class="caption-text"><span class="math notranslate nohighlight">\(\textsf{fov} = 90^\circ\)</span></span><a class="headerlink" href="#id3" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="glm-transformations">
<h2><span class="section-number">6.6. </span>glm transformations<a class="headerlink" href="#glm-transformations" title="Permalink to this heading">#</a></h2>
<p>Here we have defined the view matrix and projection matrices ourselves but it shouldn’t surprise you that there are glm functions that do this for us. These are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">glm::lookAt(position,</span> <span class="pre">target,</span> <span class="pre">worldUp)</span></code> - calculates the view matrix</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">glm::ortho(left,</span> <span class="pre">right,</span> <span class="pre">bottom,</span> <span class="pre">top,</span> <span class="pre">near,</span> <span class="pre">far)</span></code> - calculates the orthographic projection matrix</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">glm::perspective(fov,</span> <span class="pre">aspect,</span> <span class="pre">near,</span> <span class="pre">far)</span></code> - calculates the perspective projection matrix</p></li>
</ul>
<p>Comment out all the code you’ve used to calculate the <code class="docutils literal notranslate"><span class="pre">view</span></code> and <code class="docutils literal notranslate"><span class="pre">projection</span></code> matrices and add the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Calculate the view matrix</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-4.0f</span><span class="p">);</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">worldUp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">worldUp</span><span class="p">);</span>

<span class="c1">// Calculate the projection matrix</span>
<span class="kt">float</span><span class="w"> </span><span class="n">fov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">45.0f</span><span class="p">);</span>
<span class="kt">float</span><span class="w"> </span><span class="n">aspect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1024.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">768.0f</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">near</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.02f</span><span class="p">;</span>
<span class="kt">float</span><span class="w"> </span><span class="n">far</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">100.0f</span><span class="p">;</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">projection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">perspective</span><span class="p">(</span><span class="n">fov</span><span class="p">,</span><span class="w"> </span><span class="n">aspect</span><span class="p">,</span><span class="w"> </span><span class="n">near</span><span class="p">,</span><span class="w"> </span><span class="n">far</span><span class="p">);</span>
</pre></div>
</div>
<p>You should see the same output (which is good as it means our own matrices were correct).</p>
</section>
<section id="multiple-objects">
<h2><span class="section-number">6.7. </span>Multiple objects<a class="headerlink" href="#multiple-objects" title="Permalink to this heading">#</a></h2>
<p>Lets add some more cubes to our 3D world. We can do this by defining the position of each cube and then, in the render loop, we loop through each cube and calculate its <code class="docutils literal notranslate"><span class="pre">model</span></code> matrix and render it. Add the following code to your program before the do/while loop.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Cube positions</span>
<span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">cubePositions</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">5.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-10.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">-3.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-3.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">-4.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-8.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-4.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">-4.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-8.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">3.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-5.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">4.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">2.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-5.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="w"> </span><span class="mf">2.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-2.0f</span><span class="p">),</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">-1.0f</span><span class="p">,</span><span class="w">  </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">-2.0f</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This creates an array of 3-element vectors that contain the co-ordinates of the centre of 10 cubes. In the <strong>render loop</strong> comment out the code used to calculate the <code class="docutils literal notranslate"><span class="pre">model</span></code> matrix and the <code class="docutils literal notranslate"><span class="pre">glDrawArrays()</span></code> function for the previous examples and add this code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Loop through cubes and draw each one</span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Calculate model matrix</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">translate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">cubePositions</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">scale</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.5f</span><span class="p">));</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">rotate</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">),</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">30.0f</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">i</span><span class="p">),</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">));</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">model</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">translate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rotate</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Send the model view and projection matrices to the shader</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">modelID</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">model</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">viewID</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">view</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span><span class="n">glUniformMatrix4fv</span><span class="p">(</span><span class="n">projectionID</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">GL_FALSE</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">projection</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Draw the triangle</span>
<span class="w">    </span><span class="n">glDrawArrays</span><span class="p">(</span><span class="n">GL_TRIANGLES</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">3</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Here we loop through each of the elements of the <code class="docutils literal notranslate"><span class="pre">cubePositions</span></code> array. The <code class="docutils literal notranslate"><span class="pre">translate</span></code> and <code class="docutils literal notranslate"><span class="pre">rotate</span></code> matrices for each cube is calculated using the positions of the cube and the rotation vector (1, 1, 0). Note that since the camera is in the same position for each cube we send the view and projection uniforms to the shader before we loop through the cubes.</p>
<p>Change position of the camera to (0, 0, 5) and the target to (0, 0, 0),  compile and run and you should see the following.</p>
<figure class="align-default">
<a class="reference internal image-reference" href="../_images/06_multiple_cubes.png"><img alt="../_images/06_multiple_cubes.png" src="../_images/06_multiple_cubes.png" style="width: 500px;" /></a>
</figure>
<p>If you are having difficulty getting to this stage take a look at <a class="reference download internal" download="" href="../_downloads/ea06658396c88512d03b786226586209/main.cpp"><span class="xref download myst">main.cpp</span></a>, <a class="reference download internal" download="" href="../_downloads/521259cd0107c2281b0be006d8ac93cf/camera.hpp"><span class="xref download myst">camera.hpp</span></a> and <a class="reference download internal" download="" href="../_downloads/d2aaf3806e4fe15e4cb5eb2a9c4e2ba5/camera.cpp"><span class="xref download myst">camera.cpp</span></a>.</p>
</section>
<section id="a-camera-class">
<h2><span class="section-number">6.8. </span>A camera class<a class="headerlink" href="#a-camera-class" title="Permalink to this heading">#</a></h2>
<p>Our render loop is starting to look a bit messy and it would make sense to write a class to deal with the view and projection operations. Create a header and code file called <code class="docutils literal notranslate"><span class="pre">camera.hpp</span></code> and <code class="docutils literal notranslate"><span class="pre">camera.cpp</span></code> respectively in your <code class="docutils literal notranslate"><span class="pre">source/</span></code> folder. In the header file add the following code</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;GLFW/glfw3.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;glm/glm.hpp&gt;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Camera</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="c1">// Projection parameters</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">fov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">radians</span><span class="p">(</span><span class="mf">45.0f</span><span class="p">);</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">aspect</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1024.0f</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">768.0f</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">near</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.02f</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">far</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">100.0f</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Camera vectors</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">position</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">target</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">worldUp</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Transformation matrices</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">view</span><span class="p">;</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">projection</span><span class="p">;</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Constructor</span>
<span class="w">    </span><span class="n">Camera</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">Position</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Methods</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="nf">getViewMatrix</span><span class="p">();</span>
<span class="w">    </span><span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="nf">getProjectionMatrix</span><span class="p">();</span>
<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">calculateMatrices</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">getViewMatrix()</span></code> and <code class="docutils literal notranslate"><span class="pre">getProjectionMatrix()</span></code> functions will be used to return the <code class="docutils literal notranslate"><span class="pre">view</span></code> and <code class="docutils literal notranslate"><span class="pre">projection</span></code> matrices and the <code class="docutils literal notranslate"><span class="pre">calculateMatrices()</span></code> function will be used to calculate these matrices (you can see I like sensible function names).</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">camera.cpp</span></code> code file add the following code</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;GLFW/glfw3.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;glm/glm.hpp&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;glm/gtc/matrix_transform.hpp&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;camera.hpp&quot;</span>

<span class="n">Camera</span><span class="o">::</span><span class="n">Camera</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="w"> </span><span class="n">Position</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">position</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Position</span><span class="p">;</span>
<span class="w">    </span><span class="n">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="w">    </span><span class="n">worldUp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">1.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">Camera</span><span class="o">::</span><span class="n">getViewMatrix</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">view</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">Camera</span><span class="o">::</span><span class="n">getProjectionMatrix</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">projection</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="n">Camera</span><span class="o">::</span><span class="n">calculateMatrices</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Calculate view matrix</span>
<span class="w">    </span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">lookAt</span><span class="p">(</span><span class="n">position</span><span class="p">,</span><span class="w"> </span><span class="n">target</span><span class="p">,</span><span class="w"> </span><span class="n">worldUp</span><span class="p">);</span>
<span class="w">    </span>
<span class="w">    </span><span class="c1">// Calculate projection matrix</span>
<span class="w">    </span><span class="n">projection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">glm</span><span class="o">::</span><span class="n">perspective</span><span class="p">(</span><span class="n">fov</span><span class="p">,</span><span class="w"> </span><span class="n">aspect</span><span class="p">,</span><span class="w"> </span><span class="n">near</span><span class="p">,</span><span class="w"> </span><span class="n">far</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">Camera()</span></code> constructor takes in a single input of the camera position and instantiates the <code class="docutils literal notranslate"><span class="pre">position</span></code> attribute with this position. The <code class="docutils literal notranslate"><span class="pre">target</span></code> and <code class="docutils literal notranslate"><span class="pre">worldUp</span></code> vectors are instantiated with default values.</p>
<p>Now we’ve created our Camera class we need to include it and make calls to the library functions. Add <code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&quot;camera.hpp&quot;</span></code> to the top of the <code class="docutils literal notranslate"><span class="pre">main.cpp</span></code> file and create a Camera object before the <code class="docutils literal notranslate"><span class="pre">main()</span></code> function declaration.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Create camera object</span>
<span class="n">Camera</span><span class="w"> </span><span class="nf">camera</span><span class="p">(</span><span class="n">glm</span><span class="o">::</span><span class="n">vec3</span><span class="p">(</span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">0.0f</span><span class="p">,</span><span class="w"> </span><span class="mf">5.0f</span><span class="p">));</span>
</pre></div>
</div>
<p>Now all we need to do is replace the code where we calculate the view and projection matrices with the following.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Get the view and projection matrices from the camera library</span>
<span class="n">camera</span><span class="p">.</span><span class="n">calculateMatrices</span><span class="p">();</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">view</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">getViewMatrix</span><span class="p">();</span>
<span class="n">glm</span><span class="o">::</span><span class="n">mat4</span><span class="w"> </span><span class="n">projection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">camera</span><span class="p">.</span><span class="n">getProjectionMatrix</span><span class="p">();</span>
</pre></div>
</div>
<p>Compile and run your code and it should give the same result as before.</p>
</section>
<hr class="docutils" />
<section id="exercises">
<h2><span class="section-number">6.9. </span>Exercises<a class="headerlink" href="#exercises" title="Permalink to this heading">#</a></h2>
<ol class="arabic simple">
<li><p>Experiment with changing the camera position and target to see the effect this has on the 3D world.</p></li>
<li><p>Experiment with changing the field of view angle to see the effect this has.</p></li>
<li><p>Use orthographic projection for the view to screen space transformation.</p></li>
<li><p>Rotate the camera position around the first cube. Hint: <span class="math notranslate nohighlight">\(x = \tt radius \cdot \cos(\tt time)\)</span> and <span class="math notranslate nohighlight">\(z = \tt radius \cdot \sin(\tt time)\)</span> gives the co-ordinates on a circle centred at (0,0,0).</p></li>
<li><p>Rotate every other cube whilst keeping the remaining cubes stationary.</p></li>
</ol>
</section>
<hr class="docutils" />
<section id="source-code">
<h2><span class="section-number">6.10. </span>Source code<a class="headerlink" href="#source-code" title="Permalink to this heading">#</a></h2>
<p>The source code for this lab, including the exercise solutions, can be downloaded using the links below.</p>
<ul class="simple">
<li><p><a class="reference download internal" download="" href="../_downloads/4b151e57796938464491b1a3d82d5c7f/main_no_depth_test.cpp"><span class="xref download myst">main_no_depth_test.cpp</span></a> - single cube with orthographic projection and no depth testing</p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/ea06658396c88512d03b786226586209/main.cpp"><span class="xref download myst">main.cpp</span></a> - multiple cubes using the Camera class</p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/521259cd0107c2281b0be006d8ac93cf/camera.hpp"><span class="xref download myst">camera.hpp</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/d2aaf3806e4fe15e4cb5eb2a9c4e2ba5/camera.cpp"><span class="xref download myst">camera.cpp</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/9d7da34a49ec481d18e120d9b539f349/vertexShader.vert"><span class="xref download myst">vertexShader.vert</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/19a039082145d03a08163fd5f610dce4/main_exercise_solutions.cpp"><span class="xref download myst">main_exercise_solutions.cpp</span></a></p></li>
<li><p><a class="reference download internal" download="" href="../_downloads/b506e06efb23ff8b6606bae52db5aa14/camera_exercise_solutions.cpp"><span class="xref download myst">camera_exercise_solutions.cpp</span></a></p></li>
</ul>
</section>
<hr class="docutils" />
<section id="video-walkthrough">
<h2><span class="section-number">6.11. </span>Video walkthrough<a class="headerlink" href="#video-walkthrough" title="Permalink to this heading">#</a></h2>
<p>The video below walks you through these lab materials.</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/kKxjh1FGw0E?si=oTSZRExkG6A9pQ3b" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe></section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./pages"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="05_transformations.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title"><span class="section-number">5. </span>Transformations</p>
      </div>
    </a>
    <a class="right-next"
       href="07_Moving_the_camera.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">7. </span>Moving the camera</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#d-models">6.1. 3D models</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#co-ordinate-systems">6.2. Co-ordinate systems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#model-view-and-projection-matrices">6.3. Model, view and projection matrices</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-model-matrix">6.3.1. The model matrix</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-view-matrix">6.3.2. The view matrix</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#projection">6.3.3. Projection</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#applying-the-model-view-and-projection-matrices">6.3.4. Applying the model, view and projection matrices</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#the-z-buffer">6.4. The z buffer</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#perspective-projection">6.5. Perspective projection</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#changing-the-fov-angle">6.5.1. Changing the fov angle</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#glm-transformations">6.6. glm transformations</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multiple-objects">6.7. Multiple objects</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-camera-class">6.8. A camera class</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#exercises">6.9. Exercises</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#source-code">6.10. Source code</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#video-walkthrough">6.11. Video walkthrough</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Dr Jon Shiach
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>